{"ast":null,"code":"import anime from 'animejs';\nexport default class Animation {\n  //if the animation is done or not\n\n  constructor() {\n    this.animatedRegions = {};\n    //scroll regions for animations\n    this.specialAnimations = {};\n    this.animatedElements = {};\n    //elements (by selectors) and their scripted animations\n    this.initializedElements = [];\n    //elements that were changed on Start\n    this.stepDurations = [];\n    this.animationStep = 0;\n    this.animationDelay = 0;\n    this.animationDone = false;\n    console.log('blegh!');\n  }\n  async Prepare(animations, initialState, container, scrollarea = null) {\n    //get regions\n    animations.forEach(r => {\n      let start_obj = {\n        animationStep: 0,\n        animationDelay: 0,\n        stepDurations: []\n      };\n      if (r.trigger) {\n        console.log(r);\n        this.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n      } else {\n        this.animatedRegions.default = Object.assign(start_obj, r);\n      }\n    });\n    console.log('prepareAnimation!!');\n    //stepDurations = [];\n\n    console.log(this.animatedRegions);\n    await this.Start(initialState);\n    let target = document.querySelector(scrollarea);\n    console.log(target);\n    if (this.animatedRegions.default !== null && target == null) {\n      console.log('default animation!');\n      //setTimeout(()=>{\n      this.Animate('default');\n      //},10);\n    } else {\n      console.log('Not default', Object.keys(this.animatedRegions));\n      let opt = {\n        //root: document.querySelector('#nodecontainer'),\n        root: document.querySelector(container),\n        threshold: Array.from({\n          length: 21\n        }, (x, i) => i / 20)\n      };\n      let regions = [];\n      this.observer = new IntersectionObserver(entries => {\n        entries.forEach(e => {\n          if (e.isIntersecting) {\n            let target = regions.find(n => n.el === e.target);\n            if (!target.triggered && e.intersectionRatio >= target.threshold) {\n              console.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n              console.log(`${target.selector} threshold start animation!`);\n              this.Animate(target.selector);\n              target.triggered = true;\n            }\n          }\n        });\n      }, opt);\n      Object.entries(this.animatedRegions).forEach(([k, val]) => {\n        console.log(k, val);\n        let entry = document.querySelector(k);\n        regions.push({\n          el: entry,\n          selector: k,\n          threshold: val.threshold,\n          triggered: false\n        });\n        this.observer.observe(entry);\n      });\n      console.log(this.animatedRegions);\n      console.log(regions);\n    }\n  }\n  async Start(initialState) {\n    this.animationDone = false;\n    //this.animatedRegions = {};\n    //this.specialAnimations = {};\n    //this.animationStart = {};\n\n    this.clearStyles(); //clear the styles and restart animatedElements\n\n    console.log('blegh start!');\n    console.log(initialState);\n    for (let n in initialState) {\n      let element = initialState[n];\n      let selector = element.selector;\n      let selected = Array.from(document.querySelectorAll(selector));\n      console.log(selected);\n      let start_styles = element.style.split(/;\\s?/);\n\n      /* animationStart.value[selector] = {};\n      animatedElements.value[selector] = [];\n      console.log(selector, selected.length); */\n      //this.animationStart[selector] = {};\n      //this.animatedElements[selector] = [];\n\n      for (let s of start_styles) {\n        let [style_prop, style_val] = s.split(/:\\s?/);\n        style_prop = style_prop.toLowerCase();\n        console.log(style_prop, style_val);\n        for (let el of selected) {\n          console.log(el);\n          let is_svg = el instanceof SVGElement;\n          let svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform', 'stroke'];\n          if (style_prop === 'stroke-dashoffset' && is_svg) {\n            console.log('stroke-dashoffset');\n            let length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n            console.log(length);\n            style_val = length;\n            el.style.setProperty('stroke-dasharray', length + ' ' + length);\n          } else if (style_prop === 'pie') {\n            this.startPie(el.id);\n            //selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n            let angles = style_val.split(/\\s+/);\n            this.specialAnimations[el.id].startAngle = Number(angles[0]);\n            this.specialAnimations[el.id].endAngle = Number(angles[1]);\n            console.log(el.id, angles[0], angles[1]);\n            this.setPie(el.id);\n          }\n          if (is_svg && svgprops.includes(style_prop)) {\n            let original = `${style_prop}:${el.getAttribute(style_prop)}`;\n            el.setAttribute(style_prop, style_val);\n            if (!this.specialAnimations[el.id]) {\n              this.specialAnimations[el.id] = {\n                original: [original]\n              };\n            } else {\n              this.specialAnimations[el.id].original.push(original);\n            }\n            //this.specialAnimations[el.id].original = original;\n            console.log('specialAnimations', this.specialAnimations[el.id]);\n          } else {\n            el.style.setProperty(style_prop, style_val);\n          }\n          this.initializedElements.push(el);\n          /* style_prop = this.toCamelCase(style_prop);\n          this.animationStart[selector][s] = start_styles[s];\n          console.log(this.animationStart[selector]); */\n        }\n      }\n    }\n  }\n  Animate(regionname) {\n    console.log('Animate!', regionname);\n    let region = this.animatedRegions[regionname];\n    console.log(regionname, region);\n    //if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n    console.log(region.animationStep);\n    if (region.animationStep > 0) {\n      let prevstep = region.steps[region.animationStep - 1];\n      region.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n    } else {\n      //startAnimation(app);\n    }\n    //console.log(this.animationStart);\n\n    if (region.steps.length) {\n      let commands = region.steps[region.animationStep];\n      console.log(commands);\n      let elements = commands ? commands.elements || [] : [];\n      let duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n      let timing = commands ? commands.timing || 'linear' : 'linear';\n      let stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n      for (var n in elements) {\n        let styles = this.stylestringToObj(elements[n].style, true) || {};\n        console.log(styles);\n        let selector = elements[n].selector;\n        let el = elements[n];\n\n        //let selected = Array.from(document.querySelectorAll(elements[n].selector));\n        let substeps = elements[n].substeps;\n        console.log(selector);\n\n        //animeJS\n        if (!this.animatedElements[selector]) {\n          this.animatedElements[selector] = [];\n        }\n        let step = {\n          duration,\n          offset: region.animationDelay + stepoffset,\n          //absolute offset, kept here to be in the loop\n          easing: timing\n        };\n        if (substeps) {\n          step.delay = (el, i, l) => i * duration / substeps;\n          step.duration = duration / substeps;\n        }\n        console.log(this.specialAnimations);\n        if (styles['pie']) {\n          //pie\n          console.log('pie!', el.selector);\n          let pies = Array.from(document.querySelectorAll(el.selector));\n          step.targets = [];\n          pies.forEach((p, n) => {\n            let id = p.id;\n            console.log(id, this.specialAnimations[id]);\n            step.targets.push(this.specialAnimations[id]);\n          });\n          let angles = styles['pie'].split(' ');\n          step.startAngle = Number(angles[0]);\n          step.endAngle = Number(angles[1]);\n          console.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n          step.update = () => {\n            console.log('step.update', step.startAngle, step.endAngle);\n            let pies = Array.from(document.querySelectorAll(el.selector));\n            pies.forEach((p, n) => {\n              let id = p.id;\n              if (this.specialAnimations[id]) this.setPie(id);\n            });\n          };\n          delete styles['pie'];\n          step = Object.assign(step, styles);\n          console.log(step);\n          this.animatedElements[selector].push(step);\n        }\n        for (let s in styles) {\n          console.log(styles[s]);\n          if (styles[s] === 'original' && this.specialAnimations) {\n            //this was for things drawn by generated svg\n            console.log('ORIGINAL SVG!');\n            let selected = Array.from(document.querySelectorAll(elements[n].selector));\n            selected.forEach((sel, n) => {\n              let id = sel.id;\n              console.log(id);\n              if (this.specialAnimations[id] && this.specialAnimations[id].original) {\n                styles[s] = this.specialAnimations[id].original;\n              }\n            });\n          }\n          /* if (this.animationStart[selector] && this.animationStart[selector][s]) {\n          \tif (Array.isArray(this.animationStart[selector][s])) {\n          \t\tstyles[s] = [this.animationStart[selector][s][1], styles[s]];\n          \t} else {\n          \t\tstyles[s] = [this.animationStart[selector][s], styles[s]];\n          \t}\n          \t} else {\n          \tthis.animationStart[selector] = {}\n          }\n          console.log(styles[s]);\n          this.animationStart[selector][s] = styles[s]; */\n        }\n        console.log(styles);\n        step = Object.assign(step, styles);\n        this.animatedElements[selector].push(step);\n      }\n      region.animationStep++;\n      region.stepDurations.push(duration);\n      console.log(region.animationStep, region.steps.length);\n      console.log('step:', region.animationStep, 'total steps:', region.steps.length);\n      if (region.animationStep < region.steps.length) {\n        this.Animate(regionname);\n      } else if (region.animationStep === region.steps.length) {\n        //prevent double animation\n        //animeJS\n        console.log('start anime timeline');\n        let timeline = anime.timeline({\n          complete: anim => this.animationDone = true\n        });\n        console.log(this.animatedElements);\n        for (let e in this.animatedElements) {\n          let selector_steps = this.animatedElements[e];\n          console.log(selector_steps);\n          for (let s in selector_steps) {\n            let step = selector_steps[s];\n            if (!step.targets) step.targets = e;\n            console.log(step, step.offset);\n            try {\n              timeline = timeline.add(step, step.offset);\n            } catch (ex) {\n              console.log(ex.message);\n            }\n          }\n        }\n        console.log(timeline);\n      } else {\n        console.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n      }\n    }\n  }\n  cssTimeToMS(time) {\n    if (time && time.match(/s$/)) {\n      //seconds\n      return parseFloat(time) * 1000;\n    } else {\n      return parseInt(time);\n    }\n  }\n  stylestringToObj(styles, camelCase) {\n    let obj = {};\n    if (typeof styles == 'string') {\n      let rules = styles.split(/;\\s?/);\n      for (var r in rules) {\n        let rule = rules[r];\n        if (rule) {\n          let parts = rule.split(/\\s?:\\s?/);\n          console.log(parts);\n          let prop = parts[0].trim();\n          if (camelCase) prop = this.toCamelCase(prop);\n          if (parts.length === 2) obj[prop] = parts[1].trim();\n        }\n      }\n      styles = obj;\n    }\n    return styles;\n  }\n  toCamelCase(str) {\n    return str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n  }\n  //clear the style properties from elements\n  clearStyles() {\n    console.log('clearStyles animatedElements', this.animatedElements);\n    for (let sel in this.animatedElements) {\n      let elements = Array.from(document.querySelectorAll(sel));\n      for (let el of elements) {\n        console.log('clearing', el);\n        el.removeAttribute('style');\n      }\n    }\n    this.animatedElements = {};\n    console.log('clearStyles initializedElements', this.initializedElements);\n    for (let el of this.initializedElements) {\n      el.removeAttribute('style');\n    }\n    console.log('clearStyles specialAnimations', this.specialAnimations);\n    //restore originals svg attributes\n    for (let id in this.specialAnimations) {\n      let el = document.getElementById(id);\n      for (let s of (_this$specialAnimatio = this.specialAnimations[id]) === null || _this$specialAnimatio === void 0 ? void 0 : _this$specialAnimatio.original) {\n        var _this$specialAnimatio;\n        let [attr, val] = s.split(':');\n        el.setAttribute(attr, val);\n      }\n    }\n    this.specialAnimations = {};\n  }\n  //setup for the \"pie\" animation\n  startPie(id) {\n    console.log('starting pie');\n    let element = document.getElementById(id);\n    if (element) {\n      let dims;\n      /* if (element instanceof SVGElement) {\n      \tlet parentsvg = element.closest(\"svg\");\n      \tdraw = SVG(parentsvg);\n      \tconsole.log('svg element');\n      \tif (element.querySelector('clipPath')) {\n      \t\tdims = element.querySelector('clipPath').getBBox();\n      \t} else {\n      \t\tdims = element.getBBox();\n      \t}\n      \t} else {\n      \tconsole.log('not svg element');\n      \tdims = element.getBoundingClientRect();\n      \tconsole.log(dims);\n      } */\n      dims = element.getBoundingClientRect();\n      console.log(dims);\n      let center = {\n        x: dims.width / 2,\n        y: dims.height / 2\n      };\n      let radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n      if (!this.specialAnimations[id]) this.specialAnimations[id] = {};\n      console.log(center, radius);\n      this.specialAnimations[id].center = center;\n      this.specialAnimations[id].radius = radius;\n      this.specialAnimations[id].startAngle = 0;\n      this.specialAnimations[id].endAngle = 0;\n      console.log('specialAnimations', id, this.specialAnimations);\n      //arc\n      let path = this.drawPie(center.x, center.y, radius, 0, 0);\n      //element.style.clipPath = `path('${path}')`;\n      element.style.setProperty('clip-path', `path('${path}')`);\n      console.log(element);\n    }\n  }\n  //sets the values for the pie animation clip-path\n  setPie(id) {\n    console.log('setPie');\n    let center = this.specialAnimations[id].center;\n    let radius = this.specialAnimations[id].radius;\n    let start = this.specialAnimations[id].startAngle;\n    let end = this.specialAnimations[id].endAngle;\n    console.log(id, start, end);\n    try {\n      let path = this.drawPie(center.x, center.y, radius, start, end);\n      document.getElementById(id).style.setProperty('clip-path', `path('${path}')`);\n    } catch (ex) {\n      console.log(ex.message);\n    }\n  }\n  //gets the values for the path properties for \"pie\" animation\n  drawPie(x, y, radius, startAngle, endAngle) {\n    var arc = this.arcValues(x, y, radius, startAngle, endAngle);\n    var d = [\"M\", x, y, \"L\", arc.start.x, arc.start.y, \"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y, \"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y, \"Z\"].join(\" \");\n    //console.log(startAngle, endAngle, d);\n    return d;\n  }\n  //does the calculation for an arc path in \"pie\" animation\n  arcValues(x, y, radius, startAngle, endAngle) {\n    if (startAngle > endAngle) {\n      let tempAngle = startAngle;\n      startAngle = endAngle;\n      endAngle = tempAngle;\n    }\n    if (startAngle >= 360) {\n      let times = Math.floor(startAngle / 360);\n      startAngle -= times * 360;\n      endAngle -= times * 360;\n    }\n    let arcAngle = endAngle - startAngle;\n    if (arcAngle > 360) {\n      let times = Math.floor(arcAngle / 360);\n      endAngle -= times * 360;\n      arcAngle -= times * 360;\n    }\n\n    //half arcs needed because it won't draw 360\n    var start = this.polarToCartesian(x, y, radius, startAngle);\n    var start2 = this.polarToCartesian(x, y, radius, (endAngle + startAngle) / 2);\n    var end = this.polarToCartesian(x, y, radius, endAngle > 360 ? endAngle - 360 : endAngle);\n    var largeArcFlag = arcAngle / 2 <= 180 ? \"0\" : \"1\";\n    return {\n      start,\n      start2,\n      end,\n      largeArcFlag\n    };\n  }\n  //converts polar to cartesian\n  polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = this.radians(angleInDegrees - 90);\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  }\n  //converts degree angles to radians\n  radians(deg) {\n    return deg * Math.PI / 180.0;\n  }\n  //props:\n  /* let animatedRegions = {}; //regions to scroll to\n  let specialAnimations = {};\n  \tlet observer;\n  \tconst animatedElements = ref({});\n  const stepDurations = ref([]);\n  const animationStep =  ref(0);\n  const animationDelay = ref(0);\n  \tconst animationDone = ref(false);\n  const animationStart = ref({});\n  \n  //import\n  const { loadingState } = useLoadingState();\n  const { syncing } = useSync();\n  const { feedbackOpen } = useFeedback();\n  const { node, currentIndex } = usePages();\n  \n  \tconst prepareAnimation = async(app)=>{\n  \t//animationStep = 0;\n  \t//animationDelay = 0;\n  \tanimationStart.value = {};\n  \t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n  \t\t//get regions\n  \t\tnode.value.animation.animations.forEach(r=>{\n  \t\t\tlet start_obj = {\n  \t\t\t\tanimationStep:0,\n  \t\t\t\tanimationDelay:0,\n  \t\t\t\tstepDurations:[],\n  \t\t\t\t};\n  \t\t\t\tif (r.trigger){\n  \t\t\t\tconsole.log(r);\n  \t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n  \t\t\t}else{\n  \t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n  \t\t\t}\n  \t\t});\n  \t\t\tconsole.log('prepareAnimation!!');\n  \t\tanimatedElements.value = {};\n  \t\t//stepDurations = [];\n  \n  \t\tconsole.log(animatedRegions);\n  \t\t\tawait nextTick(() => {\n  \t\t\tconsole.log('nextTick');\n  \t\t\tlet target = document.querySelector('#scrollcontent');\n  \t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n  \t\t\t\tconsole.log('default animation!');\n  \t\t\t\tanimate(app, 'default');\n  \t\t\t}else{\n  \t\t\t\tconsole.log(Object.keys(animatedRegions));\n  \t\t\t\tlet opt = {\n  \t\t\t\t\troot: document.querySelector('#nodecontainer'),\n  \t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n  \t\t\t\t};\n  \t\t\t\tlet regions = [];\n  \t\t\t\tobserver = new IntersectionObserver(\n  \t\t\t\t\t(entries)=>{\n  \t\t\t\t\t\tentries.forEach(e=>{\n  \t\t\t\t\t\t\tif (e.isIntersecting){\n  \t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n  \t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n  \t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n  \t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n  \t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n  \t\t\t\t\t\t\t\t\ttarget.triggered = true;\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t});\n  \t\t\t\t\t\t},\n  \t\t\t\t\topt\n  \t\t\t\t);\n  \n  \t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n  \t\t\t\t\tconsole.log(k, val);\n  \t\t\t\t\tlet entry = document.querySelector(k);\n  \t\t\t\t\tregions.push({\n  \t\t\t\t\t\tel:entry,\n  \t\t\t\t\t\tselector:k,\n  \t\t\t\t\t\tthreshold:val.threshold,\n  \t\t\t\t\t\ttriggered:false\n  \t\t\t\t\t});\n  \t\t\t\t\t\tobserver.observe(entry);\n  \t\t\t\t});\n  \t\t\t\tconsole.log(animatedRegions);\n  \t\t\t\tconsole.log(regions);\n  \t\t\t\t}\n  \t\t});\n  \t}\n  };\n  \tconst startAnimation = (app)=>{\n  \tanimationDone.value = false;\n  \tanimatedRegions = {};\n  \tspecialAnimations = {};\n  \t\tif (!app.screenshotsMode && node.value.animation?.start){\n  \t\tlet start_elements = node.value.animation.start;\n  \t\tconsole.log(start_elements);\n  \t\tfor (let n in start_elements) {\n  \t\t\tlet element = start_elements[n];\n  \t\t\tlet selector = element.selector;\n  \t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n  \t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n  \t\t\tanimationStart.value[selector] = {};\n  \t\t\tanimatedElements.value[selector] = [];\n  \t\t\tconsole.log(selector, selected.length);\n  \t\t\t\tfor (let s in start_styles) {\n  \t\t\t\tfor (let e in selected) {\n  \t\t\t\t\tif (!selected[e].id) {\n  \t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n  \t\t\t\t\t\tlet new_id = app.generateId('animate_');\n  \t\t\t\t\t\tselected[e].id = new_id;\n  \t\t\t\t\t}\n  \t\t\t\t\tconsole.log(selected[e].id);\n  \t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n  \t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n  \t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n  \t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n  \t\t\t\t\t\tconsole.log(length);\n  \t\t\t\t\t\tstart_styles[s] = length;\n  \t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n  \t\t\t\t\t} else if (s == 'pie') {\n  \t\t\t\t\t\tstartPie(selected[e].id);\n  \t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n  \t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n  \t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n  \t\t\t\t\t\tsetPie(selected[e].id);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n  \t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n  \t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n  \t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n  \t\t\t\t\t}\n  \t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  const animate = (app, regionname)=>{\n  \tlet region = animatedRegions[regionname];\n  \tconsole.log(regionname, region);\n  \tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n  \tconsole.log(region.animationStep);\n  \t\tif (region.animationStep > 0) {\n  \t\tlet prevstep = region.steps[region.animationStep - 1];\n  \t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n  \t} else {\n  \t\t//startAnimation(app);\n  \t}\n  \tconsole.log(animationStart.value);\n  \t\tif (region.steps.length) {\n  \t\tlet commands = region.steps[region.animationStep];\n  \t\tconsole.log(commands);\n  \t\tlet elements = commands ? (commands.elements || []) : [];\n  \t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n  \t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n  \t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n  \n  \t\tfor (var n in elements) {\n  \t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n  \t\t\tlet selector = elements[n].selector;\n  \t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\tlet substeps = elements[n].substeps;\n  \t\t\tconsole.log(selector);\n  \t\t\t\t//animeJS\n  \t\t\tif (!animatedElements.value[selector]) {\n  \t\t\t\tanimatedElements.value[selector] = [];\n  \t\t\t}\n  \t\t\tlet step = {\n  \t\t\t\tduration,\n  \t\t\t\toffset: region.animationDelay + stepoffset,\n  \t\t\t\teasing: timing,\n  \t\t\t};\n  \t\t\tif (substeps) {\n  \t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n  \t\t\t\tstep.duration = duration / substeps;\n  \t\t\t}\n  \t\t\t\tconsole.log(specialAnimations);\n  \t\t\tif (styles['pie']) { //pie\n  \t\t\t\tconsole.log('pie!', elements[n].selector);\n  \t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\tstep.targets = [];\n  \t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\tlet id = p.id;\n  \t\t\t\t\tconsole.log(id, specialAnimations[id]);\n  \t\t\t\t\tstep.targets.push(specialAnimations[id]);\n  \t\t\t\t});\n  \t\t\t\tlet angles = styles['pie'].split(' ');\n  \t\t\t\tstep.startAngle = Number(angles[0]);\n  \t\t\t\tstep.endAngle = Number(angles[1]);\n  \t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n  \t\t\t\tstep.update = () => {\n  \t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n  \t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\t\tlet id = p.id;\n  \t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n  \t\t\t\t\t});\n  \t\t\t\t};\n  \t\t\t\tdelete styles['pie'];\n  \t\t\t\tstep = Object.assign(step, styles);\n  \t\t\t\tconsole.log(step);\n  \t\t\t\tanimatedElements.value[selector].push(step);\n  \t\t\t}\n  \t\t\tfor (let s in styles) {\n  \t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n  \t\t\t\t\tconsole.log('ORIGINAL SVG!');\n  \t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tselected.forEach((sel, n) => {\n  \t\t\t\t\t\tlet id = sel.id;\n  \t\t\t\t\t\tconsole.log(id);\n  \t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n  \t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n  \t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n  \t\t\t\t\t}\n  \t\t\t\t\t} else {\n  \t\t\t\t\tanimationStart.value[selector] = {}\n  \t\t\t\t}\n  \t\t\t\tanimationStart.value[selector][s] = styles[s];\n  \t\t\t}\n  \t\t\tconsole.log(styles);\n  \t\t\tstep = Object.assign(step, styles);\n  \t\t\tanimatedElements.value[selector].push(step);\n  \t\t}\n  \t\tregion.animationStep++;\n  \t\tregion.stepDurations.push(duration);\n  \t\tif (region.animationStep < region.steps.length) {\n  \t\t\tanimate(app, regionname);\n  \t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n  \t\t\t//animeJS\n  \t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n  \t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t\tconsole.log(animatedElements.value);\n  \t\t\tfor (let e in animatedElements.value) {\n  \t\t\t\tlet selector_steps = animatedElements.value[e];\n  \t\t\t\tfor (let s in selector_steps) {\n  \t\t\t\t\tlet step = selector_steps[s];\n  \t\t\t\t\tif (!step.targets) step.targets = e;\n  \t\t\t\t\tconsole.log(step);\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\ttimeline = timeline.add(step);\n  \t\t\t\t\t} catch (ex) {\n  \t\t\t\t\t\tconsole.log(ex.message);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tconsole.log(timeline);\n  \t\t} else {\n  \t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t}\n  \t}\n  }\n  const cssTimeToMS = (time)=>{\n  \tif (time && time.match(/s$/)) { //seconds\n  \t\treturn parseFloat(time) * 1000;\n  \t} else {\n  \t\treturn parseInt(time);\n  \t}\n  };\n  const startPie = (id)=>{\n  \tconsole.log('starting pie');\n  \tlet element = $id(id);\n  \tif (element) {\n  \t\tlet pie_id = id + '_pie';\n  \t\tlet draw, dims;\n  \t\tif (element instanceof SVGElement) {\n  \t\t\tlet parentsvg = element.closest(\"svg\");\n  \t\t\tdraw = SVG(parentsvg);\n  \t\t\tconsole.log('svg element');\n  \t\t\tif (element.querySelector('clipPath')) {\n  \t\t\t\tdims = element.querySelector('clipPath').getBBox();\n  \t\t\t} else {\n  \t\t\t\tdims = element.getBBox();\n  \t\t\t}\n  \t\t\t} else {\n  \t\t\tconsole.log('not svg element');\n  \t\t\tdims = element.getBoundingClientRect();\n  \t\t\tconsole.log(dims);\n  \t\t}\n  \t\tconsole.log(dims);\n  \t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n  \t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n  \n  \t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n  \t\tconsole.log(center, radius);\n  \t\tspecialAnimations[id].center = center;\n  \t\tspecialAnimations[id].radius = radius;\n  \t\tspecialAnimations[id].startAngle = 0;\n  \t\tspecialAnimations[id].endAngle = 0;\n  \t\tconsole.log('specialAnimations', id, specialAnimations);\n  \t\t//arc\n  \t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n  \t\telement.style.clipPath = `path('${path}')`;\n  \t\tconsole.log(element);\n  \t}\n  };\n  const setPie = (id)=>{\n  \t//console.log('setPie');\n  \tlet center = specialAnimations[id].center;\n  \tlet radius = specialAnimations[id].radius;\n  \tlet start = specialAnimations[id].startAngle;\n  \tlet end = specialAnimations[id].endAngle;\n  \t//console.log(id, start, end);\n  \ttry {\n  \t\tlet path = drawPie(center.x, center.y, radius, start, end);\n  \t\t$id(id).style.clipPath = `path('${path}')`;\n  \t} catch (ex) {\n  \t\tconsole.log(ex.message);\n  \t}\n  }\n  const drawPie = (x, y, radius, startAngle, endAngle)=>{\n  \tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n  \t\tvar d = [\n  \t\t\"M\", x, y,\n  \t\t\"L\", arc.start.x, arc.start.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n  \t\t\"Z\"\n  \t].join(\" \");\n  \t//console.log(startAngle, endAngle, d);\n  \treturn d;\n  };\n  \treturn {\n  \tanimatedElements,\n  \tstepDurations,\n  \tanimationStep,\n  \tanimationDelay,\n  \tspecialAnimations,\n  \tanimationDone,\n  \tprepareAnimation,\n  \tstartAnimation\n  } */\n}","map":{"version":3,"names":["anime","Animation","constructor","animatedRegions","specialAnimations","animatedElements","initializedElements","stepDurations","animationStep","animationDelay","animationDone","console","log","Prepare","animations","initialState","container","scrollarea","forEach","r","start_obj","trigger","Object","assign","default","Start","target","document","querySelector","Animate","keys","opt","root","threshold","Array","from","length","x","i","regions","observer","IntersectionObserver","entries","e","isIntersecting","find","n","el","triggered","intersectionRatio","selector","k","val","entry","push","observe","clearStyles","element","selected","querySelectorAll","start_styles","style","split","s","style_prop","style_val","toLowerCase","is_svg","SVGElement","svgprops","getTotalLength","Number","getAttribute","setProperty","startPie","id","angles","startAngle","endAngle","setPie","includes","original","setAttribute","regionname","region","prevstep","steps","cssTimeToMS","duration","offset","commands","elements","timing","stepoffset","styles","stylestringToObj","substeps","step","easing","delay","l","pies","targets","p","update","sel","timeline","complete","anim","selector_steps","add","ex","message","time","match","parseFloat","parseInt","camelCase","obj","rules","rule","parts","prop","trim","toCamelCase","str","replace","g","toUpperCase","removeAttribute","getElementById","_this$specialAnimatio","attr","dims","getBoundingClientRect","center","width","y","height","radius","Math","sqrt","pow","path","drawPie","start","end","arc","arcValues","d","largeArcFlag","start2","join","tempAngle","times","floor","arcAngle","polarToCartesian","centerX","centerY","angleInDegrees","angleInRadians","radians","cos","sin","deg","PI"],"sources":["C:/Users/Jason/projects/animation_queue/src/animation.js"],"sourcesContent":["import anime from 'animejs';\n\nexport default class Animation{\n\tanimatedRegions = {}; //scroll regions for animations\n\tspecialAnimations = {}; //number of special animations\n\n\tobserver;\n\n\tanimatedElements = {}; //elements (by selectors) and their scripted animations\n\tinitializedElements = []; //elements that were changed on Start\n\tstepDurations = [];\n\tanimationStep =  0;\n\tanimationDelay = 0;\n\n\tanimationDone = false; //if the animation is done or not\n\n\n\tconstructor(){\n\t\tconsole.log('blegh!');\n\t}\n\tasync Prepare(animations, initialState, container, scrollarea=null){\n\t\t//get regions\n\t\tanimations.forEach(r=>{\n\t\t\tlet start_obj = {\n\t\t\t\tanimationStep:0,\n\t\t\t\tanimationDelay:0,\n\t\t\t\tstepDurations:[],\n\t\t\t};\n\n\t\t\tif (r.trigger){\n\t\t\t\tconsole.log(r);\n\t\t\t\tthis.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t}else{\n\t\t\t\tthis.animatedRegions.default = Object.assign(start_obj, r);\n\t\t\t}\n\t\t});\n\n\t\tconsole.log('prepareAnimation!!');\n\t\t//stepDurations = [];\n\n\n\t\tconsole.log(this.animatedRegions);\n\t\tawait this.Start(initialState);\n\n\t\tlet target = document.querySelector(scrollarea);\n\t\tconsole.log(target);\n\n\n\t\tif (this.animatedRegions.default!==null && target==null){\n\t\t\tconsole.log('default animation!');\n\t\t\t//setTimeout(()=>{\n\t\t\t\tthis.Animate('default');\n\t\t\t//},10);\n\n\t\t}else{\n\t\t\tconsole.log('Not default', Object.keys(this.animatedRegions));\n\t\t\tlet opt = {\n\t\t\t\t//root: document.querySelector('#nodecontainer'),\n\t\t\t\troot: document.querySelector(container),\n\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t};\n\t\t\tlet regions = [];\n\t\t\tthis.observer = new IntersectionObserver(\n\t\t\t\t(entries)=>{\n\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\tlet target = regions.find(n=>n.el === e.target);\n\n\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\tthis.Animate(target.selector);\n\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t},\n\t\t\t\topt\n\t\t\t);\n\n\n\t\t\tObject.entries(this.animatedRegions).forEach(([k,val])=>{\n\t\t\t\tconsole.log(k, val);\n\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\tregions.push({\n\t\t\t\t\tel:entry,\n\t\t\t\t\tselector:k,\n\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\ttriggered:false\n\t\t\t\t});\n\n\t\t\t\tthis.observer.observe(entry);\n\t\t\t});\n\t\t\tconsole.log(this.animatedRegions);\n\t\t\tconsole.log(regions);\n\n\t\t}\n\n\t}\n\tasync Start(initialState){\n\t\tthis.animationDone = false;\n\t\t//this.animatedRegions = {};\n\t\t//this.specialAnimations = {};\n\t\t//this.animationStart = {};\n\n\n\t\tthis.clearStyles(); //clear the styles and restart animatedElements\n\n\t\tconsole.log('blegh start!');\n\n\t\tconsole.log(initialState);\n\t\tfor (let n in initialState) {\n\t\t\tlet element = initialState[n];\n\t\t\tlet selector = element.selector;\n\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\tconsole.log(selected);\n\n\n\t\t\tlet start_styles = element.style.split(/;\\s?/);\n\n\t\t\t/* animationStart.value[selector] = {};\n\t\t\tanimatedElements.value[selector] = [];\n\t\t\tconsole.log(selector, selected.length); */\n\t\t\t//this.animationStart[selector] = {};\n\t\t\t//this.animatedElements[selector] = [];\n\n\n\t\t\tfor (let s of start_styles) {\n\t\t\t\tlet [style_prop, style_val] = s.split(/:\\s?/);\n\t\t\t\tstyle_prop = style_prop.toLowerCase();\n\t\t\t\tconsole.log(style_prop, style_val);\n\t\t\t\tfor (let el of selected) {\n\t\t\t\t\tconsole.log(el);\n\n\t\t\t\t\tlet is_svg = el instanceof SVGElement;\n\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform','stroke'];\n\n\t\t\t\t\tif (style_prop === 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\tconsole.log('stroke-dashoffset');\n\t\t\t\t\t\tlet length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\tstyle_val = length;\n\t\t\t\t\t\tel.style.setProperty('stroke-dasharray', length + ' ' + length);\n\t\t\t\t\t} else if (style_prop === 'pie') {\n\t\t\t\t\t\tthis.startPie(el.id);\n\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\tlet angles = style_val.split(/\\s+/);\n\t\t\t\t\t\tthis.specialAnimations[el.id].startAngle = Number(angles[0]);\n\t\t\t\t\t\tthis.specialAnimations[el.id].endAngle = Number(angles[1]);\n\t\t\t\t\t\tconsole.log(el.id, angles[0], angles[1]);\n\t\t\t\t\t\tthis.setPie(el.id);\n\t\t\t\t\t}\n\t\t\t\t\tif (is_svg && svgprops.includes(style_prop)) {\n\t\t\t\t\t\tlet original = `${style_prop}:${el.getAttribute(style_prop)}`;\n\t\t\t\t\t\tel.setAttribute(style_prop, style_val);\n\t\t\t\t\t\tif (!this.specialAnimations[el.id]){\n\t\t\t\t\t\t\tthis.specialAnimations[el.id] = {original:[original]};\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthis.specialAnimations[el.id].original.push(original);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//this.specialAnimations[el.id].original = original;\n\t\t\t\t\t\tconsole.log('specialAnimations', this.specialAnimations[el.id]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.style.setProperty(style_prop, style_val);\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializedElements.push(el);\n\t\t\t\t\t/* style_prop = this.toCamelCase(style_prop);\n\t\t\t\t\tthis.animationStart[selector][s] = start_styles[s];\n\t\t\t\t\tconsole.log(this.animationStart[selector]); */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tAnimate(regionname){\n\t\tconsole.log('Animate!', regionname);\n\t\tlet region = this.animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\t//if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\t//console.log(this.animationStart);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = this.stylestringToObj(elements[n].style, true) || {};\n\t\t\t\tconsole.log(styles);\n\t\t\t\tlet selector = elements[n].selector;\n\t\t\t\tlet el = elements[n];\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!this.animatedElements[selector]) {\n\t\t\t\t\tthis.animatedElements[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset, //absolute offset, kept here to be in the loop\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(this.specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', el.selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(el.selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, this.specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(this.specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(el.selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (this.specialAnimations[id]) this.setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tthis.animatedElements[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tif (styles[s] === 'original' && this.specialAnimations) { //this was for things drawn by generated svg\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (this.specialAnimations[id] && this.specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = this.specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t/* if (this.animationStart[selector] && this.animationStart[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(this.animationStart[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.animationStart[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tthis.animationStart[selector][s] = styles[s]; */\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tthis.animatedElements[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tconsole.log(region.animationStep, region.steps.length);\n\t\t\tconsole.log('step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tthis.Animate(regionname);\n\t\t\t} else if (region.animationStep === region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tconsole.log('start anime timeline');\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => this.animationDone = true });\n\n\t\t\t\tconsole.log(this.animatedElements);\n\t\t\t\tfor (let e in this.animatedElements) {\n\t\t\t\t\tlet selector_steps = this.animatedElements[e];\n\t\t\t\t\tconsole.log(selector_steps);\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step, step.offset);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step, step.offset);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tcssTimeToMS(time){\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t}\n\tstylestringToObj(styles, camelCase){\n\t\tlet obj = {};\n\t\tif (typeof styles == 'string'){\n\t\t\tlet rules = styles.split(/;\\s?/);\n\t\t\tfor(var r in rules){\n\t\t\t\tlet rule = rules[r];\n\t\t\t\tif (rule){\n\t\t\t\t\tlet parts = rule.split(/\\s?:\\s?/);\n\t\t\t\t\tconsole.log(parts);\n\t\t\t\t\tlet prop = parts[0].trim();\n\t\t\t\t\tif (camelCase) prop = this.toCamelCase(prop);\n\t\t\t\t\tif (parts.length === 2) obj[prop] = parts[1].trim();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstyles = obj;\n\t\t}\n\t\treturn styles;\n\t}\n\ttoCamelCase(str){\n\t\treturn str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n\t}\n\t//clear the style properties from elements\n\tclearStyles(){\n\t\tconsole.log('clearStyles animatedElements', this.animatedElements);\n\t\tfor(let sel in this.animatedElements){\n\t\t\tlet elements = Array.from(document.querySelectorAll(sel));\n\t\t\tfor(let el of elements){\n\t\t\t\tconsole.log('clearing', el);\n\t\t\t\tel.removeAttribute('style');\n\t\t\t}\n\t\t}\n\t\tthis.animatedElements = {};\n\n\t\tconsole.log('clearStyles initializedElements', this.initializedElements);\n\t\tfor (let el of this.initializedElements) {\n\t\t\tel.removeAttribute('style');\n\t\t}\n\n\t\tconsole.log('clearStyles specialAnimations', this.specialAnimations);\n\t\t//restore originals svg attributes\n\t\tfor(let id in this.specialAnimations){\n\t\t\tlet el = document.getElementById(id);\n\t\t\tfor(let s of this.specialAnimations[id]?.original){\n\t\t\t\tlet [attr, val] = s.split(':');\n\t\t\t\tel.setAttribute(attr, val);\n\t\t\t}\n\t\t}\n\t\tthis.specialAnimations = {};\n\t}\n\t//setup for the \"pie\" animation\n\tstartPie(id){\n\t\tconsole.log('starting pie');\n\t\tlet element = document.getElementById(id);\n\t\tif (element) {\n\t\t\tlet  dims;\n\t\t\t/* if (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t} */\n\t\t\tdims = element.getBoundingClientRect();\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!this.specialAnimations[id]) this.specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tthis.specialAnimations[id].center = center;\n\t\t\tthis.specialAnimations[id].radius = radius;\n\t\t\tthis.specialAnimations[id].startAngle = 0;\n\t\t\tthis.specialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, this.specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = this.drawPie(center.x, center.y, radius, 0, 0);\n\t\t\t//element.style.clipPath = `path('${path}')`;\n\t\t\telement.style.setProperty('clip-path', `path('${path}')`);\n\t\t\tconsole.log(element);\n\t\t}\n\t}\n\t//sets the values for the pie animation clip-path\n\tsetPie(id){\n\t\tconsole.log('setPie');\n\t\tlet center = this.specialAnimations[id].center;\n\t\tlet radius = this.specialAnimations[id].radius;\n\t\tlet start = this.specialAnimations[id].startAngle;\n\t\tlet end = this.specialAnimations[id].endAngle;\n\t\tconsole.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = this.drawPie(center.x, center.y, radius, start, end);\n\t\t\tdocument.getElementById(id).style.setProperty('clip-path',`path('${path}')`);\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\t//gets the values for the path properties for \"pie\" animation\n\tdrawPie(x, y, radius, startAngle, endAngle){\n\t\tvar arc = this.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t}\n\t//does the calculation for an arc path in \"pie\" animation\n\tarcValues(x, y, radius, startAngle, endAngle){\n        if (startAngle > endAngle){\n            let tempAngle = startAngle;\n            startAngle = endAngle;\n            endAngle = tempAngle;\n        }\n        if (startAngle >= 360){\n            let times = Math.floor(startAngle/360);\n            startAngle -= times*360;\n            endAngle -= times*360;\n        }\n        let arcAngle = endAngle - startAngle;\n        if (arcAngle > 360){\n            let times = Math.floor(arcAngle/360);\n            endAngle -= times*360;\n            arcAngle -= times*360;\n        }\n\n        //half arcs needed because it won't draw 360\n        var start = this.polarToCartesian(x, y, radius, startAngle);\n        var start2 = this.polarToCartesian(x, y, radius, (endAngle+startAngle)/2);\n        var end = this.polarToCartesian(x, y, radius, endAngle > 360 ? endAngle-360 : endAngle);\n\n        var largeArcFlag = arcAngle/2 <= 180 ? \"0\" : \"1\";\n        return {start, start2, end, largeArcFlag};\n    }\n\t//converts polar to cartesian\n\tpolarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = this.radians(angleInDegrees-90);\n\n        return {\n          x: centerX + (radius * Math.cos(angleInRadians)),\n          y: centerY + (radius * Math.sin(angleInRadians))\n        };\n    }\n\t//converts degree angles to radians\n\tradians(deg){\n        return deg * Math.PI / 180.0;\n    }\n\t//props:\n\t/* let animatedRegions = {}; //regions to scroll to\n\tlet specialAnimations = {};\n\n\tlet observer;\n\n\tconst animatedElements = ref({});\n\tconst stepDurations = ref([]);\n\tconst animationStep =  ref(0);\n\tconst animationDelay = ref(0);\n\n\tconst animationDone = ref(false);\n\tconst animationStart = ref({});\n\n\n\t//import\n\tconst { loadingState } = useLoadingState();\n\tconst { syncing } = useSync();\n\tconst { feedbackOpen } = useFeedback();\n\tconst { node, currentIndex } = usePages();\n\n\n\n\tconst prepareAnimation = async(app)=>{\n\t\t//animationStep = 0;\n\t\t//animationDelay = 0;\n\t\tanimationStart.value = {};\n\n\t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n\t\t\t//get regions\n\t\t\tnode.value.animation.animations.forEach(r=>{\n\t\t\t\tlet start_obj = {\n\t\t\t\t\tanimationStep:0,\n\t\t\t\t\tanimationDelay:0,\n\t\t\t\t\tstepDurations:[],\n\n\t\t\t\t};\n\n\t\t\t\tif (r.trigger){\n\t\t\t\t\tconsole.log(r);\n\t\t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t\t}else{\n\t\t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('prepareAnimation!!');\n\t\t\tanimatedElements.value = {};\n\t\t\t//stepDurations = [];\n\n\n\t\t\tconsole.log(animatedRegions);\n\n\t\t\tawait nextTick(() => {\n\t\t\t\tconsole.log('nextTick');\n\t\t\t\tlet target = document.querySelector('#scrollcontent');\n\t\t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n\t\t\t\t\tconsole.log('default animation!');\n\t\t\t\t\tanimate(app, 'default');\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(Object.keys(animatedRegions));\n\t\t\t\t\tlet opt = {\n\t\t\t\t\t\troot: document.querySelector('#nodecontainer'),\n\t\t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t\t\t};\n\t\t\t\t\tlet regions = [];\n\t\t\t\t\tobserver = new IntersectionObserver(\n\t\t\t\t\t\t(entries)=>{\n\t\t\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n\n\t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n\t\t\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\topt\n\t\t\t\t\t);\n\n\n\t\t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n\t\t\t\t\t\tconsole.log(k, val);\n\t\t\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\t\t\tregions.push({\n\t\t\t\t\t\t\tel:entry,\n\t\t\t\t\t\t\tselector:k,\n\t\t\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\t\t\ttriggered:false\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tobserver.observe(entry);\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(animatedRegions);\n\t\t\t\t\tconsole.log(regions);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst startAnimation = (app)=>{\n\t\tanimationDone.value = false;\n\t\tanimatedRegions = {};\n\t\tspecialAnimations = {};\n\n\t\tif (!app.screenshotsMode && node.value.animation?.start){\n\t\t\tlet start_elements = node.value.animation.start;\n\t\t\tconsole.log(start_elements);\n\t\t\tfor (let n in start_elements) {\n\t\t\t\tlet element = start_elements[n];\n\t\t\t\tlet selector = element.selector;\n\t\t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n\t\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\t\tanimationStart.value[selector] = {};\n\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\tconsole.log(selector, selected.length);\n\n\t\t\t\tfor (let s in start_styles) {\n\t\t\t\t\tfor (let e in selected) {\n\t\t\t\t\t\tif (!selected[e].id) {\n\t\t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n\t\t\t\t\t\t\tlet new_id = app.generateId('animate_');\n\t\t\t\t\t\t\tselected[e].id = new_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(selected[e].id);\n\t\t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n\t\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n\t\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\t\tstart_styles[s] = length;\n\t\t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n\t\t\t\t\t\t} else if (s == 'pie') {\n\t\t\t\t\t\t\tstartPie(selected[e].id);\n\t\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\t\tsetPie(selected[e].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n\t\t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n\t\t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n\t\t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst animate = (app, regionname)=>{\n\t\tlet region = animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(animationStart.value);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n\t\t\t\tlet selector = elements[n].selector;\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!animatedElements.value[selector]) {\n\t\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanimationStart.value[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tanimationStart.value[selector][s] = styles[s];\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tanimate(app, regionname);\n\t\t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n\t\t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t\tconsole.log(animatedElements.value);\n\t\t\t\tfor (let e in animatedElements.value) {\n\t\t\t\t\tlet selector_steps = animatedElements.value[e];\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tconst cssTimeToMS = (time)=>{\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t};\n\tconst startPie = (id)=>{\n\t\tconsole.log('starting pie');\n\t\tlet element = $id(id);\n\t\tif (element) {\n\t\t\tlet pie_id = id + '_pie';\n\t\t\tlet draw, dims;\n\t\t\tif (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t}\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tspecialAnimations[id].center = center;\n\t\t\tspecialAnimations[id].radius = radius;\n\t\t\tspecialAnimations[id].startAngle = 0;\n\t\t\tspecialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n\t\t\telement.style.clipPath = `path('${path}')`;\n\t\t\tconsole.log(element);\n\t\t}\n\t};\n\tconst setPie = (id)=>{\n\t\t//console.log('setPie');\n\t\tlet center = specialAnimations[id].center;\n\t\tlet radius = specialAnimations[id].radius;\n\t\tlet start = specialAnimations[id].startAngle;\n\t\tlet end = specialAnimations[id].endAngle;\n\t\t//console.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = drawPie(center.x, center.y, radius, start, end);\n\t\t\t$id(id).style.clipPath = `path('${path}')`;\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\tconst drawPie = (x, y, radius, startAngle, endAngle)=>{\n\t\tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t};\n\n\treturn {\n\t\tanimatedElements,\n\t\tstepDurations,\n\t\tanimationStep,\n\t\tanimationDelay,\n\t\tspecialAnimations,\n\t\tanimationDone,\n\t\tprepareAnimation,\n\t\tstartAnimation\n\t} */\n}\n\n\n\n\n"],"mappings":"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,GAAG,GAAG,IAAI,CAACW,gBAAgB,CAACxH,CAAC,EAAEoG,CAAC,EAAEE,MAAM,EAAE7D,QAAQ,GAAG,GAAG,GAAGA,QAAQ,GAAC,GAAG,GAAGA,QAAQ,CAAC;IAEvF,IAAIwE,YAAY,GAAGM,QAAQ,GAAC,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG;IAChD,OAAO;MAACX,KAAK;MAAEM,MAAM;MAAEL,GAAG;MAAEI;IAAY,CAAC;EAC7C;EACH;EACAO,gBAAgBA,CAACC,OAAO,EAAEC,OAAO,EAAEpB,MAAM,EAAEqB,cAAc,EAAE;IACpD,IAAIC,cAAc,GAAG,IAAI,CAACC,OAAO,CAACF,cAAc,GAAC,EAAE,CAAC;IAEpD,OAAO;MACL3H,CAAC,EAAEyH,OAAO,GAAInB,MAAM,GAAGC,IAAI,CAACuB,GAAG,CAACF,cAAc,CAAE;MAChDxB,CAAC,EAAEsB,OAAO,GAAIpB,MAAM,GAAGC,IAAI,CAACwB,GAAG,CAACH,cAAc;IAChD,CAAC;EACL;EACH;EACAC,OAAOA,CAACG,GAAG,EAAC;IACL,OAAOA,GAAG,GAAGzB,IAAI,CAAC0B,EAAE,GAAG,KAAK;EAChC;EACH;EACA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}