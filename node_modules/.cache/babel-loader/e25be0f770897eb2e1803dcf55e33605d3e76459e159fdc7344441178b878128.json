{"ast":null,"code":"/* import { ref, nextTick } from '../../js/vue.min.js';\nimport { useLoadingState } from './loading_state.js';\nimport { usePages } from './pages_state.js';\nimport { useSync } from './sync_state.js';\nimport { useFeedback } from './feedback_state.js';\nimport { stylestring_to_obj } from \"../helpers/styles.js\";\nimport MathHelper from '../helpers/math.js'; */\nimport anime from 'animejs';\nexport default class Animation {\n  constructor() {\n    this.animatedRegions = {};\n    this.specialAnimations = {};\n    this.animatedElements = {};\n    this.stepDurations = [];\n    this.animationStep = 0;\n    this.animationDelay = 0;\n    this.animationDone = false;\n    console.log('blegh!');\n  }\n  async Prepare(animations, initialState, container, scrollarea = null) {\n    //get regions\n    animations.forEach(r => {\n      let start_obj = {\n        animationStep: 0,\n        animationDelay: 0,\n        stepDurations: []\n      };\n      if (r.trigger) {\n        console.log(r);\n        this.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n      } else {\n        this.animatedRegions.default = Object.assign(start_obj, r);\n      }\n    });\n    console.log('prepareAnimation!!');\n    this.animatedElements = {};\n    //stepDurations = [];\n\n    console.log(this.animatedRegions);\n    await this.Start(initialState);\n    let target = document.querySelector(scrollarea);\n    console.log(target);\n    if (this.animatedRegions.default !== null && target == null) {\n      console.log('default animation!');\n      setTimeout(() => {\n        this.Animate('default');\n      }, 10);\n    } else {\n      console.log('Not default', Object.keys(this.animatedRegions));\n      let opt = {\n        //root: document.querySelector('#nodecontainer'),\n        root: document.querySelector(container),\n        threshold: Array.from({\n          length: 21\n        }, (x, i) => i / 20)\n      };\n      let regions = [];\n      this.observer = new IntersectionObserver(entries => {\n        entries.forEach(e => {\n          if (e.isIntersecting) {\n            let target = regions.find(n => n.el === e.target);\n            if (!target.triggered && e.intersectionRatio >= target.threshold) {\n              console.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n              console.log(`${target.selector} threshold start animation!`);\n              this.Animate(target.selector);\n              target.triggered = true;\n            }\n          }\n        });\n      }, opt);\n      Object.entries(this.animatedRegions).forEach(([k, val]) => {\n        console.log(k, val);\n        let entry = document.querySelector(k);\n        regions.push({\n          el: entry,\n          selector: k,\n          threshold: val.threshold,\n          triggered: false\n        });\n        this.observer.observe(entry);\n      });\n      console.log(this.animatedRegions);\n      console.log(regions);\n    }\n  }\n  async Start(intialState) {\n    this.animationDone = false;\n    //this.animatedRegions = {};\n    this.specialAnimations = {};\n    console.log('blegh start!');\n    console.log(intialState);\n    for (let n in intialState) {\n      let element = intialState[n];\n      let selector = element.selector;\n      let selected = Array.from(document.querySelectorAll(selector));\n      console.log(selected);\n      let start_styles = element.style.split(/;\\s?/);\n\n      /* animationStart.value[selector] = {};\n      animatedElements.value[selector] = [];\n      console.log(selector, selected.length); */\n      this.animationStart[selector] = {};\n      this.animatedElements[selector] = [];\n      for (let s of start_styles) {\n        let [style_prop, style_val] = s.split(/:\\s?/);\n        style_prop = style_prop.toLowerCase();\n        console.log(style_prop, style_val);\n        for (let el of selected) {\n          console.log(el);\n          let is_svg = el instanceof SVGElement;\n          let svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n          if (style_prop === 'stroke-dashoffset' && is_svg) {\n            console.log('stroke-dashoffset');\n            let length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n            console.log(length);\n            style_val = length;\n            el.style.setProperty('stroke-dasharray', length + ' ' + length);\n          } else if (s === 'pie') {\n            /* startPie(selected[e].id);\n            //selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n            let angles = start_styles[s].split(' ');\n            specialAnimations[selected[e].id].startAngle = Number(angles[0]);\n            specialAnimations[selected[e].id].endAngle = Number(angles[1]);\n            console.log(selected[e].id, angles[0], angles[1]);\n            setPie(selected[e].id); */\n          }\n          if (is_svg && svgprops.indexOf(s) !== -1) {\n            let original = el.getAttribute(s);\n            el.setAttribute(s, style_val);\n            if (!this.specialAnimations[el.id]) this.specialAnimations[el.id] = {};\n            this.specialAnimations[el.id].original = original;\n          } else {\n            el.style.setProperty(style_prop, style_val);\n          }\n          let style_prop_camel = this.toCamelCase(style_prop);\n          this.animationStart[selector][style_prop_camel] = style_val;\n          console.log(this.animationStart[selector]);\n        }\n      }\n    }\n  }\n  Animate(regionname) {\n    console.log('Animate!', regionname);\n    let region = this.animatedRegions[regionname];\n    console.log(regionname, region);\n    //if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n    console.log(region.animationStep);\n    if (region.animationStep > 0) {\n      let prevstep = region.steps[region.animationStep - 1];\n      region.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n    } else {\n      //startAnimation(app);\n    }\n    console.log(this.animationStart);\n    if (region.steps.length) {\n      let commands = region.steps[region.animationStep];\n      console.log(commands);\n      let elements = commands ? commands.elements || [] : [];\n      let duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n      let timing = commands ? commands.timing || 'linear' : 'linear';\n      let stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n      for (var n in elements) {\n        let styles = this.stylestringToObj(elements[n].style, true) || {};\n        console.log(styles);\n        let selector = elements[n].selector;\n\n        //let selected = Array.from(document.querySelectorAll(elements[n].selector));\n        let substeps = elements[n].substeps;\n        console.log(selector);\n\n        //animeJS\n        if (!this.animatedElements[selector]) {\n          this.animatedElements[selector] = [];\n        }\n        let step = {\n          duration,\n          offset: region.animationDelay + stepoffset,\n          easing: timing\n        };\n        if (substeps) {\n          step.delay = (el, i, l) => i * duration / substeps;\n          step.duration = duration / substeps;\n        }\n        console.log(this.specialAnimations);\n        /* if (styles['pie']) { //pie\n        \tconsole.log('pie!', elements[n].selector);\n        \tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n        \tstep.targets = [];\n        \tpies.forEach((p, n) => {\n        \t\tlet id = p.id;\n        \t\tconsole.log(id, specialAnimations[id]);\n        \t\tstep.targets.push(specialAnimations[id]);\n        \t});\n        \tlet angles = styles['pie'].split(' ');\n        \tstep.startAngle = Number(angles[0]);\n        \tstep.endAngle = Number(angles[1]);\n        \tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n        \tstep.update = () => {\n        \t\tconsole.log('step.update', step.startAngle, step.endAngle);\n        \t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n        \t\tpies.forEach((p, n) => {\n        \t\t\tlet id = p.id;\n        \t\t\tif (specialAnimations[id]) setPie(id);\n        \t\t});\n        \t};\n        \tdelete styles['pie'];\n        \tstep = Object.assign(step, styles);\n        \tconsole.log(step);\n        \tanimatedElements.value[selector].push(step);\n        } */\n        for (let s in styles) {\n          console.log(styles[s]);\n          if (styles[s] === 'original' && this.specialAnimations) {\n            console.log('ORIGINAL SVG!');\n            let selected = Array.from(document.querySelectorAll(elements[n].selector));\n            selected.forEach((sel, n) => {\n              let id = sel.id;\n              console.log(id);\n              if (this.specialAnimations[id] && this.specialAnimations[id].original) {\n                styles[s] = this.specialAnimations[id].original;\n              }\n            });\n          }\n          if (this.animationStart[selector] && this.animationStart[selector][s]) {\n            if (Array.isArray(this.animationStart[selector][s])) {\n              console.log('isArray', this.animationStart[selector][s][1], styles[s]);\n              styles[s] = [this.animationStart[selector][s][1], styles[s]];\n            } else {\n              console.log('not array', this.animationStart[selector][s], styles[s]);\n              styles[s] = [this.animationStart[selector][s], styles[s]];\n            }\n          } else {\n            this.animationStart[selector] = {};\n          }\n          console.log(styles[s]);\n          this.animationStart[selector][s] = styles[s];\n          console.log(this.animationStart[selector][s]);\n        }\n        console.log(styles);\n        step = Object.assign(step, styles);\n        this.animatedElements[selector].push(step);\n      }\n      region.animationStep++;\n      region.stepDurations.push(duration);\n      console.log(region.animationStep, region.steps.length);\n      if (region.animationStep < region.steps.length) {\n        this.Animate(regionname);\n      } else if (region.animationStep === region.steps.length) {\n        //prevent double animation\n        //animeJS\n        let timeline = anime.timeline({\n          complete: anim => this.animationDone = true\n        });\n        console.log('step:', region.animationStep, 'total steps:', region.steps.length);\n        console.log(this.animatedElements);\n        for (let e in this.animatedElements) {\n          let selector_steps = this.animatedElements[e];\n          for (let s in selector_steps) {\n            let step = selector_steps[s];\n            if (!step.targets) step.targets = e;\n            console.log(step);\n            try {\n              timeline = timeline.add(step);\n            } catch (ex) {\n              console.log(ex.message);\n            }\n          }\n        }\n        console.log(timeline);\n      } else {\n        console.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n      }\n    }\n  }\n  cssTimeToMS(time) {\n    if (time && time.match(/s$/)) {\n      //seconds\n      return parseFloat(time) * 1000;\n    } else {\n      return parseInt(time);\n    }\n  }\n  stylestringToObj(styles, camelCase) {\n    let obj = {};\n    if (typeof styles == 'string') {\n      let rules = styles.split(/;\\s?/);\n      for (var r in rules) {\n        let rule = rules[r];\n        if (rule) {\n          let parts = rule.split(/\\s?:\\s?/);\n          console.log(parts);\n          let prop = parts[0].trim();\n          if (camelCase) prop = this.toCamelCase(prop);\n          if (parts.length === 2) obj[prop] = parts[1].trim();\n        }\n      }\n      styles = obj;\n    }\n    return styles;\n  }\n  toCamelCase(str) {\n    return str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n  }\n  //props:\n  /* let animatedRegions = {}; //regions to scroll to\n  let specialAnimations = {};\n  \tlet observer;\n  \tconst animatedElements = ref({});\n  const stepDurations = ref([]);\n  const animationStep =  ref(0);\n  const animationDelay = ref(0);\n  \tconst animationDone = ref(false);\n  const animationStart = ref({});\n  \n  //import\n  const { loadingState } = useLoadingState();\n  const { syncing } = useSync();\n  const { feedbackOpen } = useFeedback();\n  const { node, currentIndex } = usePages();\n  \n  \tconst prepareAnimation = async(app)=>{\n  \t//animationStep = 0;\n  \t//animationDelay = 0;\n  \tanimationStart.value = {};\n  \t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n  \t\t//get regions\n  \t\tnode.value.animation.animations.forEach(r=>{\n  \t\t\tlet start_obj = {\n  \t\t\t\tanimationStep:0,\n  \t\t\t\tanimationDelay:0,\n  \t\t\t\tstepDurations:[],\n  \t\t\t\t};\n  \t\t\t\tif (r.trigger){\n  \t\t\t\tconsole.log(r);\n  \t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n  \t\t\t}else{\n  \t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n  \t\t\t}\n  \t\t});\n  \t\t\tconsole.log('prepareAnimation!!');\n  \t\tanimatedElements.value = {};\n  \t\t//stepDurations = [];\n  \n  \t\tconsole.log(animatedRegions);\n  \t\t\tawait nextTick(() => {\n  \t\t\tconsole.log('nextTick');\n  \t\t\tlet target = document.querySelector('#scrollcontent');\n  \t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n  \t\t\t\tconsole.log('default animation!');\n  \t\t\t\tanimate(app, 'default');\n  \t\t\t}else{\n  \t\t\t\tconsole.log(Object.keys(animatedRegions));\n  \t\t\t\tlet opt = {\n  \t\t\t\t\troot: document.querySelector('#nodecontainer'),\n  \t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n  \t\t\t\t};\n  \t\t\t\tlet regions = [];\n  \t\t\t\tobserver = new IntersectionObserver(\n  \t\t\t\t\t(entries)=>{\n  \t\t\t\t\t\tentries.forEach(e=>{\n  \t\t\t\t\t\t\tif (e.isIntersecting){\n  \t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n  \t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n  \t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n  \t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n  \t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n  \t\t\t\t\t\t\t\t\ttarget.triggered = true;\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t});\n  \t\t\t\t\t\t},\n  \t\t\t\t\topt\n  \t\t\t\t);\n  \n  \t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n  \t\t\t\t\tconsole.log(k, val);\n  \t\t\t\t\tlet entry = document.querySelector(k);\n  \t\t\t\t\tregions.push({\n  \t\t\t\t\t\tel:entry,\n  \t\t\t\t\t\tselector:k,\n  \t\t\t\t\t\tthreshold:val.threshold,\n  \t\t\t\t\t\ttriggered:false\n  \t\t\t\t\t});\n  \t\t\t\t\t\tobserver.observe(entry);\n  \t\t\t\t});\n  \t\t\t\tconsole.log(animatedRegions);\n  \t\t\t\tconsole.log(regions);\n  \t\t\t\t}\n  \t\t});\n  \t}\n  };\n  \tconst startAnimation = (app)=>{\n  \tanimationDone.value = false;\n  \tanimatedRegions = {};\n  \tspecialAnimations = {};\n  \t\tif (!app.screenshotsMode && node.value.animation?.start){\n  \t\tlet start_elements = node.value.animation.start;\n  \t\tconsole.log(start_elements);\n  \t\tfor (let n in start_elements) {\n  \t\t\tlet element = start_elements[n];\n  \t\t\tlet selector = element.selector;\n  \t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n  \t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n  \t\t\tanimationStart.value[selector] = {};\n  \t\t\tanimatedElements.value[selector] = [];\n  \t\t\tconsole.log(selector, selected.length);\n  \t\t\t\tfor (let s in start_styles) {\n  \t\t\t\tfor (let e in selected) {\n  \t\t\t\t\tif (!selected[e].id) {\n  \t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n  \t\t\t\t\t\tlet new_id = app.generateId('animate_');\n  \t\t\t\t\t\tselected[e].id = new_id;\n  \t\t\t\t\t}\n  \t\t\t\t\tconsole.log(selected[e].id);\n  \t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n  \t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n  \t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n  \t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n  \t\t\t\t\t\tconsole.log(length);\n  \t\t\t\t\t\tstart_styles[s] = length;\n  \t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n  \t\t\t\t\t} else if (s == 'pie') {\n  \t\t\t\t\t\tstartPie(selected[e].id);\n  \t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n  \t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n  \t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n  \t\t\t\t\t\tsetPie(selected[e].id);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n  \t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n  \t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n  \t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n  \t\t\t\t\t}\n  \t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  const animate = (app, regionname)=>{\n  \tlet region = animatedRegions[regionname];\n  \tconsole.log(regionname, region);\n  \tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n  \tconsole.log(region.animationStep);\n  \t\tif (region.animationStep > 0) {\n  \t\tlet prevstep = region.steps[region.animationStep - 1];\n  \t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n  \t} else {\n  \t\t//startAnimation(app);\n  \t}\n  \tconsole.log(animationStart.value);\n  \t\tif (region.steps.length) {\n  \t\tlet commands = region.steps[region.animationStep];\n  \t\tconsole.log(commands);\n  \t\tlet elements = commands ? (commands.elements || []) : [];\n  \t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n  \t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n  \t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n  \n  \t\tfor (var n in elements) {\n  \t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n  \t\t\tlet selector = elements[n].selector;\n  \t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\tlet substeps = elements[n].substeps;\n  \t\t\tconsole.log(selector);\n  \t\t\t\t//animeJS\n  \t\t\tif (!animatedElements.value[selector]) {\n  \t\t\t\tanimatedElements.value[selector] = [];\n  \t\t\t}\n  \t\t\tlet step = {\n  \t\t\t\tduration,\n  \t\t\t\toffset: region.animationDelay + stepoffset,\n  \t\t\t\teasing: timing,\n  \t\t\t};\n  \t\t\tif (substeps) {\n  \t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n  \t\t\t\tstep.duration = duration / substeps;\n  \t\t\t}\n  \t\t\t\tconsole.log(specialAnimations);\n  \t\t\tif (styles['pie']) { //pie\n  \t\t\t\tconsole.log('pie!', elements[n].selector);\n  \t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\tstep.targets = [];\n  \t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\tlet id = p.id;\n  \t\t\t\t\tconsole.log(id, specialAnimations[id]);\n  \t\t\t\t\tstep.targets.push(specialAnimations[id]);\n  \t\t\t\t});\n  \t\t\t\tlet angles = styles['pie'].split(' ');\n  \t\t\t\tstep.startAngle = Number(angles[0]);\n  \t\t\t\tstep.endAngle = Number(angles[1]);\n  \t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n  \t\t\t\tstep.update = () => {\n  \t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n  \t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\t\tlet id = p.id;\n  \t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n  \t\t\t\t\t});\n  \t\t\t\t};\n  \t\t\t\tdelete styles['pie'];\n  \t\t\t\tstep = Object.assign(step, styles);\n  \t\t\t\tconsole.log(step);\n  \t\t\t\tanimatedElements.value[selector].push(step);\n  \t\t\t}\n  \t\t\tfor (let s in styles) {\n  \t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n  \t\t\t\t\tconsole.log('ORIGINAL SVG!');\n  \t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tselected.forEach((sel, n) => {\n  \t\t\t\t\t\tlet id = sel.id;\n  \t\t\t\t\t\tconsole.log(id);\n  \t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n  \t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n  \t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n  \t\t\t\t\t}\n  \t\t\t\t\t} else {\n  \t\t\t\t\tanimationStart.value[selector] = {}\n  \t\t\t\t}\n  \t\t\t\tanimationStart.value[selector][s] = styles[s];\n  \t\t\t}\n  \t\t\tconsole.log(styles);\n  \t\t\tstep = Object.assign(step, styles);\n  \t\t\tanimatedElements.value[selector].push(step);\n  \t\t}\n  \t\tregion.animationStep++;\n  \t\tregion.stepDurations.push(duration);\n  \t\tif (region.animationStep < region.steps.length) {\n  \t\t\tanimate(app, regionname);\n  \t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n  \t\t\t//animeJS\n  \t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n  \t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t\tconsole.log(animatedElements.value);\n  \t\t\tfor (let e in animatedElements.value) {\n  \t\t\t\tlet selector_steps = animatedElements.value[e];\n  \t\t\t\tfor (let s in selector_steps) {\n  \t\t\t\t\tlet step = selector_steps[s];\n  \t\t\t\t\tif (!step.targets) step.targets = e;\n  \t\t\t\t\tconsole.log(step);\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\ttimeline = timeline.add(step);\n  \t\t\t\t\t} catch (ex) {\n  \t\t\t\t\t\tconsole.log(ex.message);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tconsole.log(timeline);\n  \t\t} else {\n  \t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t}\n  \t}\n  }\n  const cssTimeToMS = (time)=>{\n  \tif (time && time.match(/s$/)) { //seconds\n  \t\treturn parseFloat(time) * 1000;\n  \t} else {\n  \t\treturn parseInt(time);\n  \t}\n  };\n  const startPie = (id)=>{\n  \tconsole.log('starting pie');\n  \tlet element = $id(id);\n  \tif (element) {\n  \t\tlet pie_id = id + '_pie';\n  \t\tlet draw, dims;\n  \t\tif (element instanceof SVGElement) {\n  \t\t\tlet parentsvg = element.closest(\"svg\");\n  \t\t\tdraw = SVG(parentsvg);\n  \t\t\tconsole.log('svg element');\n  \t\t\tif (element.querySelector('clipPath')) {\n  \t\t\t\tdims = element.querySelector('clipPath').getBBox();\n  \t\t\t} else {\n  \t\t\t\tdims = element.getBBox();\n  \t\t\t}\n  \t\t\t} else {\n  \t\t\tconsole.log('not svg element');\n  \t\t\tdims = element.getBoundingClientRect();\n  \t\t\tconsole.log(dims);\n  \t\t}\n  \t\tconsole.log(dims);\n  \t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n  \t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n  \n  \t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n  \t\tconsole.log(center, radius);\n  \t\tspecialAnimations[id].center = center;\n  \t\tspecialAnimations[id].radius = radius;\n  \t\tspecialAnimations[id].startAngle = 0;\n  \t\tspecialAnimations[id].endAngle = 0;\n  \t\tconsole.log('specialAnimations', id, specialAnimations);\n  \t\t//arc\n  \t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n  \t\telement.style.clipPath = `path('${path}')`;\n  \t\tconsole.log(element);\n  \t}\n  };\n  const setPie = (id)=>{\n  \t//console.log('setPie');\n  \tlet center = specialAnimations[id].center;\n  \tlet radius = specialAnimations[id].radius;\n  \tlet start = specialAnimations[id].startAngle;\n  \tlet end = specialAnimations[id].endAngle;\n  \t//console.log(id, start, end);\n  \ttry {\n  \t\tlet path = drawPie(center.x, center.y, radius, start, end);\n  \t\t$id(id).style.clipPath = `path('${path}')`;\n  \t} catch (ex) {\n  \t\tconsole.log(ex.message);\n  \t}\n  }\n  const drawPie = (x, y, radius, startAngle, endAngle)=>{\n  \tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n  \t\tvar d = [\n  \t\t\"M\", x, y,\n  \t\t\"L\", arc.start.x, arc.start.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n  \t\t\"Z\"\n  \t].join(\" \");\n  \t//console.log(startAngle, endAngle, d);\n  \treturn d;\n  };\n  \treturn {\n  \tanimatedElements,\n  \tstepDurations,\n  \tanimationStep,\n  \tanimationDelay,\n  \tspecialAnimations,\n  \tanimationDone,\n  \tprepareAnimation,\n  \tstartAnimation\n  } */\n}","map":{"version":3,"names":["anime","Animation","constructor","animatedRegions","specialAnimations","animatedElements","stepDurations","animationStep","animationDelay","animationDone","console","log","Prepare","animations","initialState","container","scrollarea","forEach","r","start_obj","trigger","Object","assign","default","Start","target","document","querySelector","setTimeout","Animate","keys","opt","root","threshold","Array","from","length","x","i","regions","observer","IntersectionObserver","entries","e","isIntersecting","find","n","el","triggered","intersectionRatio","selector","k","val","entry","push","observe","intialState","element","selected","querySelectorAll","start_styles","style","split","animationStart","s","style_prop","style_val","toLowerCase","is_svg","SVGElement","svgprops","getTotalLength","Number","getAttribute","setProperty","indexOf","original","setAttribute","id","style_prop_camel","toCamelCase","regionname","region","prevstep","steps","cssTimeToMS","duration","offset","commands","elements","timing","stepoffset","styles","stylestringToObj","substeps","step","easing","delay","l","sel","isArray","timeline","complete","anim","selector_steps","targets","add","ex","message","time","match","parseFloat","parseInt","camelCase","obj","rules","rule","parts","prop","trim","str","replace","g","toUpperCase"],"sources":["C:/Users/Jason/projects/animation_queue/src/animation.js"],"sourcesContent":["/* import { ref, nextTick } from '../../js/vue.min.js';\nimport { useLoadingState } from './loading_state.js';\nimport { usePages } from './pages_state.js';\nimport { useSync } from './sync_state.js';\nimport { useFeedback } from './feedback_state.js';\nimport { stylestring_to_obj } from \"../helpers/styles.js\";\nimport MathHelper from '../helpers/math.js'; */\nimport anime from 'animejs';\n\nexport default class Animation{\n\tanimatedRegions = {};\n\tspecialAnimations = {};\n\n\tobserver;\n\n\tanimatedElements = {};\n\tstepDurations = [];\n\tanimationStep =  0;\n\tanimationDelay = 0;\n\n\tanimationDone = false;\n\tanimationStart;\n\n\tconstructor(){\n\t\tconsole.log('blegh!');\n\t}\n\tasync Prepare(animations, initialState, container, scrollarea=null){\n\t\t//get regions\n\t\tanimations.forEach(r=>{\n\t\t\tlet start_obj = {\n\t\t\t\tanimationStep:0,\n\t\t\t\tanimationDelay:0,\n\t\t\t\tstepDurations:[],\n\t\t\t};\n\n\t\t\tif (r.trigger){\n\t\t\t\tconsole.log(r);\n\t\t\t\tthis.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t}else{\n\t\t\t\tthis.animatedRegions.default = Object.assign(start_obj, r);\n\t\t\t}\n\t\t});\n\n\t\tconsole.log('prepareAnimation!!');\n\t\tthis.animatedElements = {};\n\t\t//stepDurations = [];\n\n\n\t\tconsole.log(this.animatedRegions);\n\t\tawait this.Start(initialState);\n\n\t\tlet target = document.querySelector(scrollarea);\n\t\tconsole.log(target);\n\n\n\t\tif (this.animatedRegions.default!==null && target==null){\n\t\t\tconsole.log('default animation!');\n\t\t\tsetTimeout(()=>{\n\t\t\t\tthis.Animate('default');\n\t\t\t},10);\n\n\t\t}else{\n\t\t\tconsole.log('Not default', Object.keys(this.animatedRegions));\n\t\t\tlet opt = {\n\t\t\t\t//root: document.querySelector('#nodecontainer'),\n\t\t\t\troot: document.querySelector(container),\n\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t};\n\t\t\tlet regions = [];\n\t\t\tthis.observer = new IntersectionObserver(\n\t\t\t\t(entries)=>{\n\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\tlet target = regions.find(n=>n.el === e.target);\n\n\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\tthis.Animate(target.selector);\n\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t},\n\t\t\t\topt\n\t\t\t);\n\n\n\t\t\tObject.entries(this.animatedRegions).forEach(([k,val])=>{\n\t\t\t\tconsole.log(k, val);\n\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\tregions.push({\n\t\t\t\t\tel:entry,\n\t\t\t\t\tselector:k,\n\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\ttriggered:false\n\t\t\t\t});\n\n\t\t\t\tthis.observer.observe(entry);\n\t\t\t});\n\t\t\tconsole.log(this.animatedRegions);\n\t\t\tconsole.log(regions);\n\n\t\t}\n\n\t}\n\tasync Start(intialState){\n\t\tthis.animationDone = false;\n\t\t//this.animatedRegions = {};\n\t\tthis.specialAnimations = {};\n\n\t\tconsole.log('blegh start!');\n\n\t\tconsole.log(intialState);\n\t\tfor (let n in intialState) {\n\t\t\tlet element = intialState[n];\n\t\t\tlet selector = element.selector;\n\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\tconsole.log(selected);\n\n\n\t\t\tlet start_styles = element.style.split(/;\\s?/);\n\n\t\t\t/* animationStart.value[selector] = {};\n\t\t\tanimatedElements.value[selector] = [];\n\t\t\tconsole.log(selector, selected.length); */\n\t\t\tthis.animationStart[selector] = {};\n\t\t\tthis.animatedElements[selector] = [];\n\n\n\t\t\tfor (let s of start_styles) {\n\t\t\t\tlet [style_prop, style_val] = s.split(/:\\s?/);\n\t\t\t\tstyle_prop = style_prop.toLowerCase();\n\t\t\t\tconsole.log(style_prop, style_val);\n\t\t\t\tfor (let el of selected) {\n\t\t\t\t\tconsole.log(el);\n\n\t\t\t\t\tlet is_svg = el instanceof SVGElement;\n\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\tif (style_prop === 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\tconsole.log('stroke-dashoffset');\n\t\t\t\t\t\tlet length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\tstyle_val = length;\n\t\t\t\t\t\tel.style.setProperty('stroke-dasharray', length + ' ' + length);\n\t\t\t\t\t} else if (s === 'pie') {\n\t\t\t\t\t\t/* startPie(selected[e].id);\n\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\tsetPie(selected[e].id); */\n\t\t\t\t\t}\n\t\t\t\t\tif (is_svg && svgprops.indexOf(s) !== -1) {\n\t\t\t\t\t\tlet original = el.getAttribute(s);\n\t\t\t\t\t\tel.setAttribute(s, style_val);\n\t\t\t\t\t\t if (!this.specialAnimations[el.id]) this.specialAnimations[el.id] = {};\n\t\t\t\t\t\tthis.specialAnimations[el.id].original = original;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.style.setProperty(style_prop, style_val);\n\t\t\t\t\t}\n\t\t\t\t\tlet style_prop_camel = this.toCamelCase(style_prop)\n\t\t\t\t\tthis.animationStart[selector][style_prop_camel] = style_val;\n\t\t\t\t\tconsole.log(this.animationStart[selector]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tAnimate(regionname){\n\t\tconsole.log('Animate!', regionname);\n\t\tlet region = this.animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\t//if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(this.animationStart);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = this.stylestringToObj(elements[n].style, true) || {};\n\t\t\t\tconsole.log(styles);\n\t\t\t\tlet selector = elements[n].selector;\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!this.animatedElements[selector]) {\n\t\t\t\t\tthis.animatedElements[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(this.specialAnimations);\n\t\t\t\t/* if (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t\t} */\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tif (styles[s] === 'original' && this.specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (this.specialAnimations[id] && this.specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = this.specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (this.animationStart[selector] && this.animationStart[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(this.animationStart[selector][s])) {\n\t\t\t\t\t\t\tconsole.log('isArray', this.animationStart[selector][s][1], styles[s]);\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log('not array', this.animationStart[selector][s], styles[s]);\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.animationStart[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tthis.animationStart[selector][s] = styles[s];\n\t\t\t\t\tconsole.log(this.animationStart[selector][s]);\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tthis.animatedElements[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tconsole.log(region.animationStep, region.steps.length);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tthis.Animate(regionname);\n\t\t\t} else if (region.animationStep === region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => this.animationDone = true });\n\t\t\t\tconsole.log('step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t\tconsole.log(this.animatedElements);\n\t\t\t\tfor (let e in this.animatedElements) {\n\t\t\t\t\tlet selector_steps = this.animatedElements[e];\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tcssTimeToMS(time){\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t}\n\tstylestringToObj(styles, camelCase){\n\t\tlet obj = {};\n\t\tif (typeof styles == 'string'){\n\t\t\tlet rules = styles.split(/;\\s?/);\n\t\t\tfor(var r in rules){\n\t\t\t\tlet rule = rules[r];\n\t\t\t\tif (rule){\n\t\t\t\t\tlet parts = rule.split(/\\s?:\\s?/);\n\t\t\t\t\tconsole.log(parts);\n\t\t\t\t\tlet prop = parts[0].trim();\n\t\t\t\t\tif (camelCase) prop = this.toCamelCase(prop);\n\t\t\t\t\tif (parts.length === 2) obj[prop] = parts[1].trim();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstyles = obj;\n\t\t}\n\t\treturn styles;\n\t}\n\ttoCamelCase(str){\n\t\treturn str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n\t}\n\t//props:\n\t/* let animatedRegions = {}; //regions to scroll to\n\tlet specialAnimations = {};\n\n\tlet observer;\n\n\tconst animatedElements = ref({});\n\tconst stepDurations = ref([]);\n\tconst animationStep =  ref(0);\n\tconst animationDelay = ref(0);\n\n\tconst animationDone = ref(false);\n\tconst animationStart = ref({});\n\n\n\t//import\n\tconst { loadingState } = useLoadingState();\n\tconst { syncing } = useSync();\n\tconst { feedbackOpen } = useFeedback();\n\tconst { node, currentIndex } = usePages();\n\n\n\n\tconst prepareAnimation = async(app)=>{\n\t\t//animationStep = 0;\n\t\t//animationDelay = 0;\n\t\tanimationStart.value = {};\n\n\t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n\t\t\t//get regions\n\t\t\tnode.value.animation.animations.forEach(r=>{\n\t\t\t\tlet start_obj = {\n\t\t\t\t\tanimationStep:0,\n\t\t\t\t\tanimationDelay:0,\n\t\t\t\t\tstepDurations:[],\n\n\t\t\t\t};\n\n\t\t\t\tif (r.trigger){\n\t\t\t\t\tconsole.log(r);\n\t\t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t\t}else{\n\t\t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('prepareAnimation!!');\n\t\t\tanimatedElements.value = {};\n\t\t\t//stepDurations = [];\n\n\n\t\t\tconsole.log(animatedRegions);\n\n\t\t\tawait nextTick(() => {\n\t\t\t\tconsole.log('nextTick');\n\t\t\t\tlet target = document.querySelector('#scrollcontent');\n\t\t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n\t\t\t\t\tconsole.log('default animation!');\n\t\t\t\t\tanimate(app, 'default');\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(Object.keys(animatedRegions));\n\t\t\t\t\tlet opt = {\n\t\t\t\t\t\troot: document.querySelector('#nodecontainer'),\n\t\t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t\t\t};\n\t\t\t\t\tlet regions = [];\n\t\t\t\t\tobserver = new IntersectionObserver(\n\t\t\t\t\t\t(entries)=>{\n\t\t\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n\n\t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n\t\t\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\topt\n\t\t\t\t\t);\n\n\n\t\t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n\t\t\t\t\t\tconsole.log(k, val);\n\t\t\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\t\t\tregions.push({\n\t\t\t\t\t\t\tel:entry,\n\t\t\t\t\t\t\tselector:k,\n\t\t\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\t\t\ttriggered:false\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tobserver.observe(entry);\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(animatedRegions);\n\t\t\t\t\tconsole.log(regions);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst startAnimation = (app)=>{\n\t\tanimationDone.value = false;\n\t\tanimatedRegions = {};\n\t\tspecialAnimations = {};\n\n\t\tif (!app.screenshotsMode && node.value.animation?.start){\n\t\t\tlet start_elements = node.value.animation.start;\n\t\t\tconsole.log(start_elements);\n\t\t\tfor (let n in start_elements) {\n\t\t\t\tlet element = start_elements[n];\n\t\t\t\tlet selector = element.selector;\n\t\t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n\t\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\t\tanimationStart.value[selector] = {};\n\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\tconsole.log(selector, selected.length);\n\n\t\t\t\tfor (let s in start_styles) {\n\t\t\t\t\tfor (let e in selected) {\n\t\t\t\t\t\tif (!selected[e].id) {\n\t\t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n\t\t\t\t\t\t\tlet new_id = app.generateId('animate_');\n\t\t\t\t\t\t\tselected[e].id = new_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(selected[e].id);\n\t\t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n\t\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n\t\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\t\tstart_styles[s] = length;\n\t\t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n\t\t\t\t\t\t} else if (s == 'pie') {\n\t\t\t\t\t\t\tstartPie(selected[e].id);\n\t\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\t\tsetPie(selected[e].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n\t\t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n\t\t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n\t\t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst animate = (app, regionname)=>{\n\t\tlet region = animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(animationStart.value);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n\t\t\t\tlet selector = elements[n].selector;\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!animatedElements.value[selector]) {\n\t\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanimationStart.value[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tanimationStart.value[selector][s] = styles[s];\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tanimate(app, regionname);\n\t\t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n\t\t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t\tconsole.log(animatedElements.value);\n\t\t\t\tfor (let e in animatedElements.value) {\n\t\t\t\t\tlet selector_steps = animatedElements.value[e];\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tconst cssTimeToMS = (time)=>{\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t};\n\tconst startPie = (id)=>{\n\t\tconsole.log('starting pie');\n\t\tlet element = $id(id);\n\t\tif (element) {\n\t\t\tlet pie_id = id + '_pie';\n\t\t\tlet draw, dims;\n\t\t\tif (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t}\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tspecialAnimations[id].center = center;\n\t\t\tspecialAnimations[id].radius = radius;\n\t\t\tspecialAnimations[id].startAngle = 0;\n\t\t\tspecialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n\t\t\telement.style.clipPath = `path('${path}')`;\n\t\t\tconsole.log(element);\n\t\t}\n\t};\n\tconst setPie = (id)=>{\n\t\t//console.log('setPie');\n\t\tlet center = specialAnimations[id].center;\n\t\tlet radius = specialAnimations[id].radius;\n\t\tlet start = specialAnimations[id].startAngle;\n\t\tlet end = specialAnimations[id].endAngle;\n\t\t//console.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = drawPie(center.x, center.y, radius, start, end);\n\t\t\t$id(id).style.clipPath = `path('${path}')`;\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\tconst drawPie = (x, y, radius, startAngle, endAngle)=>{\n\t\tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t};\n\n\treturn {\n\t\tanimatedElements,\n\t\tstepDurations,\n\t\tanimationStep,\n\t\tanimationDelay,\n\t\tspecialAnimations,\n\t\tanimationDone,\n\t\tprepareAnimation,\n\t\tstartAnimation\n\t} */\n}\n\n\n\n\n"],"mappings":"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pD,OAAO,CAACC,GAAG,CAAC0G,KAAK,CAAC;UAClB,IAAIC,IAAI,GAAGD,KAAK,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;UAC1B,IAAIN,SAAS,EAAEK,IAAI,GAAG,IAAI,CAACtC,WAAW,CAACsC,IAAI,CAAC;UAC5C,IAAID,KAAK,CAACjF,MAAM,KAAK,CAAC,EAAE8E,GAAG,CAACI,IAAI,CAAC,GAAGD,KAAK,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QACpD;MACD;MACA3B,MAAM,GAAGsB,GAAG;IACb;IACA,OAAOtB,MAAM;EACd;EACAZ,WAAWA,CAACwC,GAAG,EAAC;IACf,OAAOA,GAAG,CAACC,OAAO,CAAC,WAAW,EAAEC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;EACzD;EACA;EACA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}