{"ast":null,"code":"import anime from 'animejs';\nexport default class Animation {\n  //if the animation is done or not\n  //animationStart = {}; //previous values for the sake of anime.js start and end range\n\n  constructor() {\n    this.animatedRegions = {};\n    //scroll regions for animations\n    this.specialAnimations = {};\n    this.animatedElements = {};\n    //elements (by selectors) and their scripted animations\n    this.stepDurations = [];\n    this.animationStep = 0;\n    this.animationDelay = 0;\n    this.animationDone = false;\n    console.log('blegh!');\n  }\n  async Prepare(animations, initialState, container, scrollarea = null) {\n    //get regions\n    animations.forEach(r => {\n      let start_obj = {\n        animationStep: 0,\n        animationDelay: 0,\n        stepDurations: []\n      };\n      if (r.trigger) {\n        console.log(r);\n        this.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n      } else {\n        this.animatedRegions.default = Object.assign(start_obj, r);\n      }\n    });\n    console.log('prepareAnimation!!');\n    //stepDurations = [];\n\n    console.log(this.animatedRegions);\n    await this.Start(initialState);\n    let target = document.querySelector(scrollarea);\n    console.log(target);\n    if (this.animatedRegions.default !== null && target == null) {\n      console.log('default animation!');\n      //setTimeout(()=>{\n      this.Animate('default');\n      //},10);\n    } else {\n      console.log('Not default', Object.keys(this.animatedRegions));\n      let opt = {\n        //root: document.querySelector('#nodecontainer'),\n        root: document.querySelector(container),\n        threshold: Array.from({\n          length: 21\n        }, (x, i) => i / 20)\n      };\n      let regions = [];\n      this.observer = new IntersectionObserver(entries => {\n        entries.forEach(e => {\n          if (e.isIntersecting) {\n            let target = regions.find(n => n.el === e.target);\n            if (!target.triggered && e.intersectionRatio >= target.threshold) {\n              console.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n              console.log(`${target.selector} threshold start animation!`);\n              this.Animate(target.selector);\n              target.triggered = true;\n            }\n          }\n        });\n      }, opt);\n      Object.entries(this.animatedRegions).forEach(([k, val]) => {\n        console.log(k, val);\n        let entry = document.querySelector(k);\n        regions.push({\n          el: entry,\n          selector: k,\n          threshold: val.threshold,\n          triggered: false\n        });\n        this.observer.observe(entry);\n      });\n      console.log(this.animatedRegions);\n      console.log(regions);\n    }\n  }\n  async Start(intialState) {\n    this.animationDone = false;\n    //this.animatedRegions = {};\n    this.specialAnimations = {};\n    //this.animationStart = {};\n\n    this.clearStyles(); //clear the styles and restart animatedElements\n\n    console.log('blegh start!');\n    console.log(intialState);\n    for (let n in intialState) {\n      let element = intialState[n];\n      let selector = element.selector;\n      let selected = Array.from(document.querySelectorAll(selector));\n      console.log(selected);\n      let start_styles = element.style.split(/;\\s?/);\n\n      /* animationStart.value[selector] = {};\n      animatedElements.value[selector] = [];\n      console.log(selector, selected.length); */\n      //this.animationStart[selector] = {};\n      //this.animatedElements[selector] = [];\n\n      for (let s of start_styles) {\n        let [style_prop, style_val] = s.split(/:\\s?/);\n        style_prop = style_prop.toLowerCase();\n        console.log(style_prop, style_val);\n        for (let el of selected) {\n          console.log(el);\n          let is_svg = el instanceof SVGElement;\n          let svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n          if (style_prop === 'stroke-dashoffset' && is_svg) {\n            console.log('stroke-dashoffset');\n            let length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n            console.log(length);\n            style_val = length;\n            el.style.setProperty('stroke-dasharray', length + ' ' + length);\n          } else if (style_prop === 'pie') {\n            this.startPie(el.id);\n            //selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n            let angles = start_styles[s].split(/\\s+/);\n            this.specialAnimations[el.id].startAngle = Number(angles[0]);\n            this.specialAnimations[el.id].endAngle = Number(angles[1]);\n            console.log(el.id, angles[0], angles[1]);\n            this.setPie(el.id);\n          }\n          if (is_svg && svgprops.indexOf(s) !== -1) {\n            let original = el.getAttribute(s);\n            el.setAttribute(s, style_val);\n            if (!this.specialAnimations[el.id]) this.specialAnimations[el.id] = {};\n            this.specialAnimations[el.id].original = original;\n          } else {\n            el.style.setProperty(style_prop, style_val);\n          }\n          /* style_prop = this.toCamelCase(style_prop);\n          this.animationStart[selector][s] = start_styles[s];\n          console.log(this.animationStart[selector]); */\n        }\n      }\n    }\n  }\n  Animate(regionname) {\n    console.log('Animate!', regionname);\n    let region = this.animatedRegions[regionname];\n    console.log(regionname, region);\n    //if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n    console.log(region.animationStep);\n    if (region.animationStep > 0) {\n      let prevstep = region.steps[region.animationStep - 1];\n      region.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n    } else {\n      //startAnimation(app);\n    }\n    console.log(this.animationStart);\n    if (region.steps.length) {\n      let commands = region.steps[region.animationStep];\n      console.log(commands);\n      let elements = commands ? commands.elements || [] : [];\n      let duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n      let timing = commands ? commands.timing || 'linear' : 'linear';\n      let stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n      for (var n in elements) {\n        let styles = this.stylestringToObj(elements[n].style, true) || {};\n        console.log(styles);\n        let selector = elements[n].selector;\n        let el = elements[n];\n\n        //let selected = Array.from(document.querySelectorAll(elements[n].selector));\n        let substeps = elements[n].substeps;\n        console.log(selector);\n\n        //animeJS\n        if (!this.animatedElements[selector]) {\n          this.animatedElements[selector] = [];\n        }\n        let step = {\n          duration,\n          offset: region.animationDelay + stepoffset,\n          easing: timing\n        };\n        if (substeps) {\n          step.delay = (el, i, l) => i * duration / substeps;\n          step.duration = duration / substeps;\n        }\n        console.log(this.specialAnimations);\n        if (styles['pie']) {\n          //pie\n          console.log('pie!', elements[n].selector);\n          let pies = Array.from(document.querySelectorAll(elements[n].selector));\n          step.targets = [];\n          pies.forEach((p, n) => {\n            let id = p.id;\n            console.log(id, this.specialAnimations[id]);\n            step.targets.push(this.specialAnimations[id]);\n          });\n          let angles = styles['pie'].split(' ');\n          step.startAngle = Number(angles[0]);\n          step.endAngle = Number(angles[1]);\n          console.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n          step.update = () => {\n            console.log('step.update', step.startAngle, step.endAngle);\n            let pies = Array.from(document.querySelectorAll(elements[n].selector));\n            pies.forEach((p, n) => {\n              let id = p.id;\n              if (this.specialAnimations[id]) this.setPie(id);\n            });\n          };\n          delete styles['pie'];\n          step = Object.assign(step, styles);\n          console.log(step);\n          this.animatedElements[selector].push(step);\n        }\n        for (let s in styles) {\n          console.log(styles[s]);\n          if (styles[s] === 'original' && this.specialAnimations) {\n            console.log('ORIGINAL SVG!');\n            let selected = Array.from(document.querySelectorAll(elements[n].selector));\n            selected.forEach((sel, n) => {\n              let id = sel.id;\n              console.log(id);\n              if (this.specialAnimations[id] && this.specialAnimations[id].original) {\n                styles[s] = this.specialAnimations[id].original;\n              }\n            });\n          }\n          /* if (this.animationStart[selector] && this.animationStart[selector][s]) {\n          \tif (Array.isArray(this.animationStart[selector][s])) {\n          \t\tstyles[s] = [this.animationStart[selector][s][1], styles[s]];\n          \t} else {\n          \t\tstyles[s] = [this.animationStart[selector][s], styles[s]];\n          \t}\n          \t} else {\n          \tthis.animationStart[selector] = {}\n          }\n          console.log(styles[s]);\n          this.animationStart[selector][s] = styles[s]; */\n        }\n        console.log(styles);\n        step = Object.assign(step, styles);\n        this.animatedElements[selector].push(step);\n      }\n      region.animationStep++;\n      region.stepDurations.push(duration);\n      console.log(region.animationStep, region.steps.length);\n      console.log('step:', region.animationStep, 'total steps:', region.steps.length);\n      if (region.animationStep < region.steps.length) {\n        this.Animate(regionname);\n      } else if (region.animationStep === region.steps.length) {\n        //prevent double animation\n        //animeJS\n        console.log('start anime timeline');\n        let timeline = anime.timeline({\n          complete: anim => this.animationDone = true\n        });\n        console.log(this.animatedElements);\n        for (let e in this.animatedElements) {\n          let selector_steps = this.animatedElements[e];\n          console.log(selector_steps);\n          for (let s in selector_steps) {\n            let step = selector_steps[s];\n            if (!step.targets) step.targets = e;\n            console.log(step);\n            try {\n              timeline = timeline.add(step);\n            } catch (ex) {\n              console.log(ex.message);\n            }\n          }\n        }\n        console.log(timeline);\n      } else {\n        console.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n      }\n    }\n  }\n  cssTimeToMS(time) {\n    if (time && time.match(/s$/)) {\n      //seconds\n      return parseFloat(time) * 1000;\n    } else {\n      return parseInt(time);\n    }\n  }\n  stylestringToObj(styles, camelCase) {\n    let obj = {};\n    if (typeof styles == 'string') {\n      let rules = styles.split(/;\\s?/);\n      for (var r in rules) {\n        let rule = rules[r];\n        if (rule) {\n          let parts = rule.split(/\\s?:\\s?/);\n          console.log(parts);\n          let prop = parts[0].trim();\n          if (camelCase) prop = this.toCamelCase(prop);\n          if (parts.length === 2) obj[prop] = parts[1].trim();\n        }\n      }\n      styles = obj;\n    }\n    return styles;\n  }\n  toCamelCase(str) {\n    return str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n  }\n  //clear the style properties from elements\n  clearStyles() {\n    console.log('clearStyles', this.animatedElements);\n    for (let sel in this.animatedElements) {\n      let elements = Array.from(document.querySelectorAll(sel));\n      for (let el of elements) {\n        console.log('clearing', el);\n        el.removeAttribute('style');\n      }\n    }\n    console.log('clearStyles specialAnimations', this.specialAnimations);\n    this.animatedElements = {};\n  }\n  //setup for the \"pie\" animation\n  startPie(id) {\n    console.log('starting pie');\n    let element = document.getElementById(id);\n    if (element) {\n      let pie_id = id + '_pie';\n      let draw, dims;\n      /* if (element instanceof SVGElement) {\n      \tlet parentsvg = element.closest(\"svg\");\n      \tdraw = SVG(parentsvg);\n      \tconsole.log('svg element');\n      \tif (element.querySelector('clipPath')) {\n      \t\tdims = element.querySelector('clipPath').getBBox();\n      \t} else {\n      \t\tdims = element.getBBox();\n      \t}\n      \t} else {\n      \tconsole.log('not svg element');\n      \tdims = element.getBoundingClientRect();\n      \tconsole.log(dims);\n      } */\n      dims = element.getBoundingClientRect();\n      console.log(dims);\n      let center = {\n        x: dims.width / 2,\n        y: dims.height / 2\n      };\n      let radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n      if (!this.specialAnimations[id]) this.specialAnimations[id] = {};\n      console.log(center, radius);\n      this.specialAnimations[id].center = center;\n      this.specialAnimations[id].radius = radius;\n      this.specialAnimations[id].startAngle = 0;\n      this.specialAnimations[id].endAngle = 0;\n      console.log('specialAnimations', id, this.specialAnimations);\n      //arc\n      let path = this.drawPie(center.x, center.y, radius, 0, 0);\n      //element.style.clipPath = `path('${path}')`;\n      element.style.setProperty('clip-path', `path('${path}')`);\n      console.log(element);\n    }\n  }\n  //sets the values for the pie animation clip-path\n  setPie(id) {\n    console.log('setPie');\n    let center = this.specialAnimations[id].center;\n    let radius = this.specialAnimations[id].radius;\n    let start = this.specialAnimations[id].startAngle;\n    let end = this.specialAnimations[id].endAngle;\n    console.log(id, start, end);\n    try {\n      let path = this.drawPie(center.x, center.y, radius, start, end);\n      document.getElementById(id).style.setProperty('clip-path', `path('${path}')`);\n    } catch (ex) {\n      console.log(ex.message);\n    }\n  }\n  //gets the values for the path properties for \"pie\" animation\n  drawPie(x, y, radius, startAngle, endAngle) {\n    var arc = this.arcValues(x, y, radius, startAngle, endAngle);\n    var d = [\"M\", x, y, \"L\", arc.start.x, arc.start.y, \"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y, \"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y, \"Z\"].join(\" \");\n    //console.log(startAngle, endAngle, d);\n    return d;\n  }\n  //does the calculation for an arc path in \"pie\" animation\n  arcValues(x, y, radius, startAngle, endAngle) {\n    if (startAngle > endAngle) {\n      let tempAngle = startAngle;\n      startAngle = endAngle;\n      endAngle = tempAngle;\n    }\n    if (startAngle >= 360) {\n      let times = Math.floor(startAngle / 360);\n      startAngle -= times * 360;\n      endAngle -= times * 360;\n    }\n    let arcAngle = endAngle - startAngle;\n    if (arcAngle > 360) {\n      let times = Math.floor(arcAngle / 360);\n      endAngle -= times * 360;\n      arcAngle -= times * 360;\n    }\n\n    //half arcs needed because it won't draw 360\n    var start = this.polarToCartesian(x, y, radius, startAngle);\n    var start2 = this.polarToCartesian(x, y, radius, (endAngle + startAngle) / 2);\n    var end = this.polarToCartesian(x, y, radius, endAngle > 360 ? endAngle - 360 : endAngle);\n    var largeArcFlag = arcAngle / 2 <= 180 ? \"0\" : \"1\";\n    return {\n      start,\n      start2,\n      end,\n      largeArcFlag\n    };\n  }\n  //converts polar to cartesian\n  polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = this.radians(angleInDegrees - 90);\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    };\n  }\n  //converts degree angles to radians\n  radians(deg) {\n    return deg * Math.PI / 180.0;\n  }\n  //props:\n  /* let animatedRegions = {}; //regions to scroll to\n  let specialAnimations = {};\n  \tlet observer;\n  \tconst animatedElements = ref({});\n  const stepDurations = ref([]);\n  const animationStep =  ref(0);\n  const animationDelay = ref(0);\n  \tconst animationDone = ref(false);\n  const animationStart = ref({});\n  \n  //import\n  const { loadingState } = useLoadingState();\n  const { syncing } = useSync();\n  const { feedbackOpen } = useFeedback();\n  const { node, currentIndex } = usePages();\n  \n  \tconst prepareAnimation = async(app)=>{\n  \t//animationStep = 0;\n  \t//animationDelay = 0;\n  \tanimationStart.value = {};\n  \t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n  \t\t//get regions\n  \t\tnode.value.animation.animations.forEach(r=>{\n  \t\t\tlet start_obj = {\n  \t\t\t\tanimationStep:0,\n  \t\t\t\tanimationDelay:0,\n  \t\t\t\tstepDurations:[],\n  \t\t\t\t};\n  \t\t\t\tif (r.trigger){\n  \t\t\t\tconsole.log(r);\n  \t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n  \t\t\t}else{\n  \t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n  \t\t\t}\n  \t\t});\n  \t\t\tconsole.log('prepareAnimation!!');\n  \t\tanimatedElements.value = {};\n  \t\t//stepDurations = [];\n  \n  \t\tconsole.log(animatedRegions);\n  \t\t\tawait nextTick(() => {\n  \t\t\tconsole.log('nextTick');\n  \t\t\tlet target = document.querySelector('#scrollcontent');\n  \t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n  \t\t\t\tconsole.log('default animation!');\n  \t\t\t\tanimate(app, 'default');\n  \t\t\t}else{\n  \t\t\t\tconsole.log(Object.keys(animatedRegions));\n  \t\t\t\tlet opt = {\n  \t\t\t\t\troot: document.querySelector('#nodecontainer'),\n  \t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n  \t\t\t\t};\n  \t\t\t\tlet regions = [];\n  \t\t\t\tobserver = new IntersectionObserver(\n  \t\t\t\t\t(entries)=>{\n  \t\t\t\t\t\tentries.forEach(e=>{\n  \t\t\t\t\t\t\tif (e.isIntersecting){\n  \t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n  \t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n  \t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n  \t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n  \t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n  \t\t\t\t\t\t\t\t\ttarget.triggered = true;\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t});\n  \t\t\t\t\t\t},\n  \t\t\t\t\topt\n  \t\t\t\t);\n  \n  \t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n  \t\t\t\t\tconsole.log(k, val);\n  \t\t\t\t\tlet entry = document.querySelector(k);\n  \t\t\t\t\tregions.push({\n  \t\t\t\t\t\tel:entry,\n  \t\t\t\t\t\tselector:k,\n  \t\t\t\t\t\tthreshold:val.threshold,\n  \t\t\t\t\t\ttriggered:false\n  \t\t\t\t\t});\n  \t\t\t\t\t\tobserver.observe(entry);\n  \t\t\t\t});\n  \t\t\t\tconsole.log(animatedRegions);\n  \t\t\t\tconsole.log(regions);\n  \t\t\t\t}\n  \t\t});\n  \t}\n  };\n  \tconst startAnimation = (app)=>{\n  \tanimationDone.value = false;\n  \tanimatedRegions = {};\n  \tspecialAnimations = {};\n  \t\tif (!app.screenshotsMode && node.value.animation?.start){\n  \t\tlet start_elements = node.value.animation.start;\n  \t\tconsole.log(start_elements);\n  \t\tfor (let n in start_elements) {\n  \t\t\tlet element = start_elements[n];\n  \t\t\tlet selector = element.selector;\n  \t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n  \t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n  \t\t\tanimationStart.value[selector] = {};\n  \t\t\tanimatedElements.value[selector] = [];\n  \t\t\tconsole.log(selector, selected.length);\n  \t\t\t\tfor (let s in start_styles) {\n  \t\t\t\tfor (let e in selected) {\n  \t\t\t\t\tif (!selected[e].id) {\n  \t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n  \t\t\t\t\t\tlet new_id = app.generateId('animate_');\n  \t\t\t\t\t\tselected[e].id = new_id;\n  \t\t\t\t\t}\n  \t\t\t\t\tconsole.log(selected[e].id);\n  \t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n  \t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n  \t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n  \t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n  \t\t\t\t\t\tconsole.log(length);\n  \t\t\t\t\t\tstart_styles[s] = length;\n  \t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n  \t\t\t\t\t} else if (s == 'pie') {\n  \t\t\t\t\t\tstartPie(selected[e].id);\n  \t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n  \t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n  \t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n  \t\t\t\t\t\tsetPie(selected[e].id);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n  \t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n  \t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n  \t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n  \t\t\t\t\t}\n  \t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  const animate = (app, regionname)=>{\n  \tlet region = animatedRegions[regionname];\n  \tconsole.log(regionname, region);\n  \tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n  \tconsole.log(region.animationStep);\n  \t\tif (region.animationStep > 0) {\n  \t\tlet prevstep = region.steps[region.animationStep - 1];\n  \t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n  \t} else {\n  \t\t//startAnimation(app);\n  \t}\n  \tconsole.log(animationStart.value);\n  \t\tif (region.steps.length) {\n  \t\tlet commands = region.steps[region.animationStep];\n  \t\tconsole.log(commands);\n  \t\tlet elements = commands ? (commands.elements || []) : [];\n  \t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n  \t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n  \t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n  \n  \t\tfor (var n in elements) {\n  \t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n  \t\t\tlet selector = elements[n].selector;\n  \t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\tlet substeps = elements[n].substeps;\n  \t\t\tconsole.log(selector);\n  \t\t\t\t//animeJS\n  \t\t\tif (!animatedElements.value[selector]) {\n  \t\t\t\tanimatedElements.value[selector] = [];\n  \t\t\t}\n  \t\t\tlet step = {\n  \t\t\t\tduration,\n  \t\t\t\toffset: region.animationDelay + stepoffset,\n  \t\t\t\teasing: timing,\n  \t\t\t};\n  \t\t\tif (substeps) {\n  \t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n  \t\t\t\tstep.duration = duration / substeps;\n  \t\t\t}\n  \t\t\t\tconsole.log(specialAnimations);\n  \t\t\tif (styles['pie']) { //pie\n  \t\t\t\tconsole.log('pie!', elements[n].selector);\n  \t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\tstep.targets = [];\n  \t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\tlet id = p.id;\n  \t\t\t\t\tconsole.log(id, specialAnimations[id]);\n  \t\t\t\t\tstep.targets.push(specialAnimations[id]);\n  \t\t\t\t});\n  \t\t\t\tlet angles = styles['pie'].split(' ');\n  \t\t\t\tstep.startAngle = Number(angles[0]);\n  \t\t\t\tstep.endAngle = Number(angles[1]);\n  \t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n  \t\t\t\tstep.update = () => {\n  \t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n  \t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\t\tlet id = p.id;\n  \t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n  \t\t\t\t\t});\n  \t\t\t\t};\n  \t\t\t\tdelete styles['pie'];\n  \t\t\t\tstep = Object.assign(step, styles);\n  \t\t\t\tconsole.log(step);\n  \t\t\t\tanimatedElements.value[selector].push(step);\n  \t\t\t}\n  \t\t\tfor (let s in styles) {\n  \t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n  \t\t\t\t\tconsole.log('ORIGINAL SVG!');\n  \t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tselected.forEach((sel, n) => {\n  \t\t\t\t\t\tlet id = sel.id;\n  \t\t\t\t\t\tconsole.log(id);\n  \t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n  \t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n  \t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n  \t\t\t\t\t}\n  \t\t\t\t\t} else {\n  \t\t\t\t\tanimationStart.value[selector] = {}\n  \t\t\t\t}\n  \t\t\t\tanimationStart.value[selector][s] = styles[s];\n  \t\t\t}\n  \t\t\tconsole.log(styles);\n  \t\t\tstep = Object.assign(step, styles);\n  \t\t\tanimatedElements.value[selector].push(step);\n  \t\t}\n  \t\tregion.animationStep++;\n  \t\tregion.stepDurations.push(duration);\n  \t\tif (region.animationStep < region.steps.length) {\n  \t\t\tanimate(app, regionname);\n  \t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n  \t\t\t//animeJS\n  \t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n  \t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t\tconsole.log(animatedElements.value);\n  \t\t\tfor (let e in animatedElements.value) {\n  \t\t\t\tlet selector_steps = animatedElements.value[e];\n  \t\t\t\tfor (let s in selector_steps) {\n  \t\t\t\t\tlet step = selector_steps[s];\n  \t\t\t\t\tif (!step.targets) step.targets = e;\n  \t\t\t\t\tconsole.log(step);\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\ttimeline = timeline.add(step);\n  \t\t\t\t\t} catch (ex) {\n  \t\t\t\t\t\tconsole.log(ex.message);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tconsole.log(timeline);\n  \t\t} else {\n  \t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t}\n  \t}\n  }\n  const cssTimeToMS = (time)=>{\n  \tif (time && time.match(/s$/)) { //seconds\n  \t\treturn parseFloat(time) * 1000;\n  \t} else {\n  \t\treturn parseInt(time);\n  \t}\n  };\n  const startPie = (id)=>{\n  \tconsole.log('starting pie');\n  \tlet element = $id(id);\n  \tif (element) {\n  \t\tlet pie_id = id + '_pie';\n  \t\tlet draw, dims;\n  \t\tif (element instanceof SVGElement) {\n  \t\t\tlet parentsvg = element.closest(\"svg\");\n  \t\t\tdraw = SVG(parentsvg);\n  \t\t\tconsole.log('svg element');\n  \t\t\tif (element.querySelector('clipPath')) {\n  \t\t\t\tdims = element.querySelector('clipPath').getBBox();\n  \t\t\t} else {\n  \t\t\t\tdims = element.getBBox();\n  \t\t\t}\n  \t\t\t} else {\n  \t\t\tconsole.log('not svg element');\n  \t\t\tdims = element.getBoundingClientRect();\n  \t\t\tconsole.log(dims);\n  \t\t}\n  \t\tconsole.log(dims);\n  \t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n  \t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n  \n  \t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n  \t\tconsole.log(center, radius);\n  \t\tspecialAnimations[id].center = center;\n  \t\tspecialAnimations[id].radius = radius;\n  \t\tspecialAnimations[id].startAngle = 0;\n  \t\tspecialAnimations[id].endAngle = 0;\n  \t\tconsole.log('specialAnimations', id, specialAnimations);\n  \t\t//arc\n  \t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n  \t\telement.style.clipPath = `path('${path}')`;\n  \t\tconsole.log(element);\n  \t}\n  };\n  const setPie = (id)=>{\n  \t//console.log('setPie');\n  \tlet center = specialAnimations[id].center;\n  \tlet radius = specialAnimations[id].radius;\n  \tlet start = specialAnimations[id].startAngle;\n  \tlet end = specialAnimations[id].endAngle;\n  \t//console.log(id, start, end);\n  \ttry {\n  \t\tlet path = drawPie(center.x, center.y, radius, start, end);\n  \t\t$id(id).style.clipPath = `path('${path}')`;\n  \t} catch (ex) {\n  \t\tconsole.log(ex.message);\n  \t}\n  }\n  const drawPie = (x, y, radius, startAngle, endAngle)=>{\n  \tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n  \t\tvar d = [\n  \t\t\"M\", x, y,\n  \t\t\"L\", arc.start.x, arc.start.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n  \t\t\"Z\"\n  \t].join(\" \");\n  \t//console.log(startAngle, endAngle, d);\n  \treturn d;\n  };\n  \treturn {\n  \tanimatedElements,\n  \tstepDurations,\n  \tanimationStep,\n  \tanimationDelay,\n  \tspecialAnimations,\n  \tanimationDone,\n  \tprepareAnimation,\n  \tstartAnimation\n  } */\n}","map":{"version":3,"names":["anime","Animation","constructor","animatedRegions","specialAnimations","animatedElements","stepDurations","animationStep","animationDelay","animationDone","console","log","Prepare","animations","initialState","container","scrollarea","forEach","r","start_obj","trigger","Object","assign","default","Start","target","document","querySelector","Animate","keys","opt","root","threshold","Array","from","length","x","i","regions","observer","IntersectionObserver","entries","e","isIntersecting","find","n","el","triggered","intersectionRatio","selector","k","val","entry","push","observe","intialState","clearStyles","element","selected","querySelectorAll","start_styles","style","split","s","style_prop","style_val","toLowerCase","is_svg","SVGElement","svgprops","getTotalLength","Number","getAttribute","setProperty","startPie","id","angles","startAngle","endAngle","setPie","indexOf","original","setAttribute","regionname","region","prevstep","steps","cssTimeToMS","duration","offset","animationStart","commands","elements","timing","stepoffset","styles","stylestringToObj","substeps","step","easing","delay","l","pies","targets","p","update","sel","timeline","complete","anim","selector_steps","add","ex","message","time","match","parseFloat","parseInt","camelCase","obj","rules","rule","parts","prop","trim","toCamelCase","str","replace","g","toUpperCase","removeAttribute","getElementById","pie_id","draw","dims","getBoundingClientRect","center","width","y","height","radius","Math","sqrt","pow","path","drawPie","start","end","arc","arcValues","d","largeArcFlag","start2","join","tempAngle","times","floor","arcAngle","polarToCartesian","centerX","centerY","angleInDegrees","angleInRadians","radians","cos","sin","deg","PI"],"sources":["C:/Users/Jason/projects/animation_queue/src/animation.js"],"sourcesContent":["import anime from 'animejs';\n\nexport default class Animation{\n\tanimatedRegions = {}; //scroll regions for animations\n\tspecialAnimations = {}; //number of special animations\n\n\tobserver;\n\n\tanimatedElements = {}; //elements (by selectors) and their scripted animations\n\tstepDurations = [];\n\tanimationStep =  0;\n\tanimationDelay = 0;\n\n\tanimationDone = false; //if the animation is done or not\n\t//animationStart = {}; //previous values for the sake of anime.js start and end range\n\n\tconstructor(){\n\t\tconsole.log('blegh!');\n\t}\n\tasync Prepare(animations, initialState, container, scrollarea=null){\n\t\t//get regions\n\t\tanimations.forEach(r=>{\n\t\t\tlet start_obj = {\n\t\t\t\tanimationStep:0,\n\t\t\t\tanimationDelay:0,\n\t\t\t\tstepDurations:[],\n\t\t\t};\n\n\t\t\tif (r.trigger){\n\t\t\t\tconsole.log(r);\n\t\t\t\tthis.animatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t}else{\n\t\t\t\tthis.animatedRegions.default = Object.assign(start_obj, r);\n\t\t\t}\n\t\t});\n\n\t\tconsole.log('prepareAnimation!!');\n\t\t//stepDurations = [];\n\n\n\t\tconsole.log(this.animatedRegions);\n\t\tawait this.Start(initialState);\n\n\t\tlet target = document.querySelector(scrollarea);\n\t\tconsole.log(target);\n\n\n\t\tif (this.animatedRegions.default!==null && target==null){\n\t\t\tconsole.log('default animation!');\n\t\t\t//setTimeout(()=>{\n\t\t\t\tthis.Animate('default');\n\t\t\t//},10);\n\n\t\t}else{\n\t\t\tconsole.log('Not default', Object.keys(this.animatedRegions));\n\t\t\tlet opt = {\n\t\t\t\t//root: document.querySelector('#nodecontainer'),\n\t\t\t\troot: document.querySelector(container),\n\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t};\n\t\t\tlet regions = [];\n\t\t\tthis.observer = new IntersectionObserver(\n\t\t\t\t(entries)=>{\n\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\tlet target = regions.find(n=>n.el === e.target);\n\n\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\tthis.Animate(target.selector);\n\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t},\n\t\t\t\topt\n\t\t\t);\n\n\n\t\t\tObject.entries(this.animatedRegions).forEach(([k,val])=>{\n\t\t\t\tconsole.log(k, val);\n\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\tregions.push({\n\t\t\t\t\tel:entry,\n\t\t\t\t\tselector:k,\n\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\ttriggered:false\n\t\t\t\t});\n\n\t\t\t\tthis.observer.observe(entry);\n\t\t\t});\n\t\t\tconsole.log(this.animatedRegions);\n\t\t\tconsole.log(regions);\n\n\t\t}\n\n\t}\n\tasync Start(intialState){\n\t\tthis.animationDone = false;\n\t\t//this.animatedRegions = {};\n\t\tthis.specialAnimations = {};\n\t\t//this.animationStart = {};\n\n\n\t\tthis.clearStyles(); //clear the styles and restart animatedElements\n\n\t\tconsole.log('blegh start!');\n\n\t\tconsole.log(intialState);\n\t\tfor (let n in intialState) {\n\t\t\tlet element = intialState[n];\n\t\t\tlet selector = element.selector;\n\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\tconsole.log(selected);\n\n\n\t\t\tlet start_styles = element.style.split(/;\\s?/);\n\n\t\t\t/* animationStart.value[selector] = {};\n\t\t\tanimatedElements.value[selector] = [];\n\t\t\tconsole.log(selector, selected.length); */\n\t\t\t//this.animationStart[selector] = {};\n\t\t\t//this.animatedElements[selector] = [];\n\n\n\t\t\tfor (let s of start_styles) {\n\t\t\t\tlet [style_prop, style_val] = s.split(/:\\s?/);\n\t\t\t\tstyle_prop = style_prop.toLowerCase();\n\t\t\t\tconsole.log(style_prop, style_val);\n\t\t\t\tfor (let el of selected) {\n\t\t\t\t\tconsole.log(el);\n\n\t\t\t\t\tlet is_svg = el instanceof SVGElement;\n\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\tif (style_prop === 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\tconsole.log('stroke-dashoffset');\n\t\t\t\t\t\tlet length = el.getTotalLength() + Number(el.getAttribute('stroke-width'));\n\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\tstyle_val = length;\n\t\t\t\t\t\tel.style.setProperty('stroke-dasharray', length + ' ' + length);\n\t\t\t\t\t} else if (style_prop === 'pie') {\n\t\t\t\t\t\tthis.startPie(el.id);\n\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\tlet angles = start_styles[s].split(/\\s+/);\n\t\t\t\t\t\tthis.specialAnimations[el.id].startAngle = Number(angles[0]);\n\t\t\t\t\t\tthis.specialAnimations[el.id].endAngle = Number(angles[1]);\n\t\t\t\t\t\tconsole.log(el.id, angles[0], angles[1]);\n\t\t\t\t\t\tthis.setPie(el.id);\n\t\t\t\t\t}\n\t\t\t\t\tif (is_svg && svgprops.indexOf(s) !== -1) {\n\t\t\t\t\t\tlet original = el.getAttribute(s);\n\t\t\t\t\t\tel.setAttribute(s, style_val);\n\t\t\t\t\t\tif (!this.specialAnimations[el.id]) this.specialAnimations[el.id] = {};\n\t\t\t\t\t\tthis.specialAnimations[el.id].original = original;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.style.setProperty(style_prop, style_val);\n\t\t\t\t\t}\n\t\t\t\t\t/* style_prop = this.toCamelCase(style_prop);\n\t\t\t\t\tthis.animationStart[selector][s] = start_styles[s];\n\t\t\t\t\tconsole.log(this.animationStart[selector]); */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tAnimate(regionname){\n\t\tconsole.log('Animate!', regionname);\n\t\tlet region = this.animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\t//if (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += this.cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? this.cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(this.animationStart);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? this.cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? this.cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = this.stylestringToObj(elements[n].style, true) || {};\n\t\t\t\tconsole.log(styles);\n\t\t\t\tlet selector = elements[n].selector;\n\t\t\t\tlet el = elements[n];\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!this.animatedElements[selector]) {\n\t\t\t\t\tthis.animatedElements[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(this.specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, this.specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(this.specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (this.specialAnimations[id]) this.setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tthis.animatedElements[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tif (styles[s] === 'original' && this.specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (this.specialAnimations[id] && this.specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = this.specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t/* if (this.animationStart[selector] && this.animationStart[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(this.animationStart[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [this.animationStart[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.animationStart[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(styles[s]);\n\t\t\t\t\tthis.animationStart[selector][s] = styles[s]; */\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tthis.animatedElements[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tconsole.log(region.animationStep, region.steps.length);\n\t\t\tconsole.log('step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tthis.Animate(regionname);\n\t\t\t} else if (region.animationStep === region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tconsole.log('start anime timeline');\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => this.animationDone = true });\n\n\t\t\t\tconsole.log(this.animatedElements);\n\t\t\t\tfor (let e in this.animatedElements) {\n\t\t\t\t\tlet selector_steps = this.animatedElements[e];\n\t\t\t\t\tconsole.log(selector_steps);\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tcssTimeToMS(time){\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t}\n\tstylestringToObj(styles, camelCase){\n\t\tlet obj = {};\n\t\tif (typeof styles == 'string'){\n\t\t\tlet rules = styles.split(/;\\s?/);\n\t\t\tfor(var r in rules){\n\t\t\t\tlet rule = rules[r];\n\t\t\t\tif (rule){\n\t\t\t\t\tlet parts = rule.split(/\\s?:\\s?/);\n\t\t\t\t\tconsole.log(parts);\n\t\t\t\t\tlet prop = parts[0].trim();\n\t\t\t\t\tif (camelCase) prop = this.toCamelCase(prop);\n\t\t\t\t\tif (parts.length === 2) obj[prop] = parts[1].trim();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstyles = obj;\n\t\t}\n\t\treturn styles;\n\t}\n\ttoCamelCase(str){\n\t\treturn str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n\t}\n\t//clear the style properties from elements\n\tclearStyles(){\n\t\tconsole.log('clearStyles', this.animatedElements);\n\t\tfor(let sel in this.animatedElements){\n\t\t\tlet elements = Array.from(document.querySelectorAll(sel));\n\t\t\tfor(let el of elements){\n\t\t\t\tconsole.log('clearing', el);\n\t\t\t\tel.removeAttribute('style');\n\t\t\t}\n\t\t}\n\t\tconsole.log('clearStyles specialAnimations', this.specialAnimations);\n\t\tthis.animatedElements = {};\n\t}\n\t//setup for the \"pie\" animation\n\tstartPie(id){\n\t\tconsole.log('starting pie');\n\t\tlet element = document.getElementById(id);\n\t\tif (element) {\n\t\t\tlet pie_id = id + '_pie';\n\t\t\tlet draw, dims;\n\t\t\t/* if (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t} */\n\t\t\tdims = element.getBoundingClientRect();\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!this.specialAnimations[id]) this.specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tthis.specialAnimations[id].center = center;\n\t\t\tthis.specialAnimations[id].radius = radius;\n\t\t\tthis.specialAnimations[id].startAngle = 0;\n\t\t\tthis.specialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, this.specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = this.drawPie(center.x, center.y, radius, 0, 0);\n\t\t\t//element.style.clipPath = `path('${path}')`;\n\t\t\telement.style.setProperty('clip-path', `path('${path}')`);\n\t\t\tconsole.log(element);\n\t\t}\n\t}\n\t//sets the values for the pie animation clip-path\n\tsetPie(id){\n\t\tconsole.log('setPie');\n\t\tlet center = this.specialAnimations[id].center;\n\t\tlet radius = this.specialAnimations[id].radius;\n\t\tlet start = this.specialAnimations[id].startAngle;\n\t\tlet end = this.specialAnimations[id].endAngle;\n\t\tconsole.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = this.drawPie(center.x, center.y, radius, start, end);\n\t\t\tdocument.getElementById(id).style.setProperty('clip-path',`path('${path}')`);\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\t//gets the values for the path properties for \"pie\" animation\n\tdrawPie(x, y, radius, startAngle, endAngle){\n\t\tvar arc = this.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t}\n\t//does the calculation for an arc path in \"pie\" animation\n\tarcValues(x, y, radius, startAngle, endAngle){\n        if (startAngle > endAngle){\n            let tempAngle = startAngle;\n            startAngle = endAngle;\n            endAngle = tempAngle;\n        }\n        if (startAngle >= 360){\n            let times = Math.floor(startAngle/360);\n            startAngle -= times*360;\n            endAngle -= times*360;\n        }\n        let arcAngle = endAngle - startAngle;\n        if (arcAngle > 360){\n            let times = Math.floor(arcAngle/360);\n            endAngle -= times*360;\n            arcAngle -= times*360;\n        }\n\n        //half arcs needed because it won't draw 360\n        var start = this.polarToCartesian(x, y, radius, startAngle);\n        var start2 = this.polarToCartesian(x, y, radius, (endAngle+startAngle)/2);\n        var end = this.polarToCartesian(x, y, radius, endAngle > 360 ? endAngle-360 : endAngle);\n\n        var largeArcFlag = arcAngle/2 <= 180 ? \"0\" : \"1\";\n        return {start, start2, end, largeArcFlag};\n    }\n\t//converts polar to cartesian\n\tpolarToCartesian(centerX, centerY, radius, angleInDegrees) {\n        var angleInRadians = this.radians(angleInDegrees-90);\n\n        return {\n          x: centerX + (radius * Math.cos(angleInRadians)),\n          y: centerY + (radius * Math.sin(angleInRadians))\n        };\n    }\n\t//converts degree angles to radians\n\tradians(deg){\n        return deg * Math.PI / 180.0;\n    }\n\t//props:\n\t/* let animatedRegions = {}; //regions to scroll to\n\tlet specialAnimations = {};\n\n\tlet observer;\n\n\tconst animatedElements = ref({});\n\tconst stepDurations = ref([]);\n\tconst animationStep =  ref(0);\n\tconst animationDelay = ref(0);\n\n\tconst animationDone = ref(false);\n\tconst animationStart = ref({});\n\n\n\t//import\n\tconst { loadingState } = useLoadingState();\n\tconst { syncing } = useSync();\n\tconst { feedbackOpen } = useFeedback();\n\tconst { node, currentIndex } = usePages();\n\n\n\n\tconst prepareAnimation = async(app)=>{\n\t\t//animationStep = 0;\n\t\t//animationDelay = 0;\n\t\tanimationStart.value = {};\n\n\t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n\t\t\t//get regions\n\t\t\tnode.value.animation.animations.forEach(r=>{\n\t\t\t\tlet start_obj = {\n\t\t\t\t\tanimationStep:0,\n\t\t\t\t\tanimationDelay:0,\n\t\t\t\t\tstepDurations:[],\n\n\t\t\t\t};\n\n\t\t\t\tif (r.trigger){\n\t\t\t\t\tconsole.log(r);\n\t\t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t\t}else{\n\t\t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('prepareAnimation!!');\n\t\t\tanimatedElements.value = {};\n\t\t\t//stepDurations = [];\n\n\n\t\t\tconsole.log(animatedRegions);\n\n\t\t\tawait nextTick(() => {\n\t\t\t\tconsole.log('nextTick');\n\t\t\t\tlet target = document.querySelector('#scrollcontent');\n\t\t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n\t\t\t\t\tconsole.log('default animation!');\n\t\t\t\t\tanimate(app, 'default');\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(Object.keys(animatedRegions));\n\t\t\t\t\tlet opt = {\n\t\t\t\t\t\troot: document.querySelector('#nodecontainer'),\n\t\t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t\t\t};\n\t\t\t\t\tlet regions = [];\n\t\t\t\t\tobserver = new IntersectionObserver(\n\t\t\t\t\t\t(entries)=>{\n\t\t\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n\n\t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n\t\t\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\topt\n\t\t\t\t\t);\n\n\n\t\t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n\t\t\t\t\t\tconsole.log(k, val);\n\t\t\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\t\t\tregions.push({\n\t\t\t\t\t\t\tel:entry,\n\t\t\t\t\t\t\tselector:k,\n\t\t\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\t\t\ttriggered:false\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tobserver.observe(entry);\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(animatedRegions);\n\t\t\t\t\tconsole.log(regions);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst startAnimation = (app)=>{\n\t\tanimationDone.value = false;\n\t\tanimatedRegions = {};\n\t\tspecialAnimations = {};\n\n\t\tif (!app.screenshotsMode && node.value.animation?.start){\n\t\t\tlet start_elements = node.value.animation.start;\n\t\t\tconsole.log(start_elements);\n\t\t\tfor (let n in start_elements) {\n\t\t\t\tlet element = start_elements[n];\n\t\t\t\tlet selector = element.selector;\n\t\t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n\t\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\t\tanimationStart.value[selector] = {};\n\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\tconsole.log(selector, selected.length);\n\n\t\t\t\tfor (let s in start_styles) {\n\t\t\t\t\tfor (let e in selected) {\n\t\t\t\t\t\tif (!selected[e].id) {\n\t\t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n\t\t\t\t\t\t\tlet new_id = app.generateId('animate_');\n\t\t\t\t\t\t\tselected[e].id = new_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(selected[e].id);\n\t\t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n\t\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n\t\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\t\tstart_styles[s] = length;\n\t\t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n\t\t\t\t\t\t} else if (s == 'pie') {\n\t\t\t\t\t\t\tstartPie(selected[e].id);\n\t\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\t\tsetPie(selected[e].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n\t\t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n\t\t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n\t\t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst animate = (app, regionname)=>{\n\t\tlet region = animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(animationStart.value);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n\t\t\t\tlet selector = elements[n].selector;\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!animatedElements.value[selector]) {\n\t\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanimationStart.value[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tanimationStart.value[selector][s] = styles[s];\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tanimate(app, regionname);\n\t\t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n\t\t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t\tconsole.log(animatedElements.value);\n\t\t\t\tfor (let e in animatedElements.value) {\n\t\t\t\t\tlet selector_steps = animatedElements.value[e];\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tconst cssTimeToMS = (time)=>{\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t};\n\tconst startPie = (id)=>{\n\t\tconsole.log('starting pie');\n\t\tlet element = $id(id);\n\t\tif (element) {\n\t\t\tlet pie_id = id + '_pie';\n\t\t\tlet draw, dims;\n\t\t\tif (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t}\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tspecialAnimations[id].center = center;\n\t\t\tspecialAnimations[id].radius = radius;\n\t\t\tspecialAnimations[id].startAngle = 0;\n\t\t\tspecialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n\t\t\telement.style.clipPath = `path('${path}')`;\n\t\t\tconsole.log(element);\n\t\t}\n\t};\n\tconst setPie = (id)=>{\n\t\t//console.log('setPie');\n\t\tlet center = specialAnimations[id].center;\n\t\tlet radius = specialAnimations[id].radius;\n\t\tlet start = specialAnimations[id].startAngle;\n\t\tlet end = specialAnimations[id].endAngle;\n\t\t//console.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = drawPie(center.x, center.y, radius, start, end);\n\t\t\t$id(id).style.clipPath = `path('${path}')`;\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\tconst drawPie = (x, y, radius, startAngle, endAngle)=>{\n\t\tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t};\n\n\treturn {\n\t\tanimatedElements,\n\t\tstepDurations,\n\t\tanimationStep,\n\t\tanimationDelay,\n\t\tspecialAnimations,\n\t\tanimationDone,\n\t\tprepareAnimation,\n\t\tstartAnimation\n\t} */\n}\n\n\n\n\n"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}