{"ast":null,"code":"/* import { ref, nextTick } from '../../js/vue.min.js';\nimport { useLoadingState } from './loading_state.js';\nimport { usePages } from './pages_state.js';\nimport { useSync } from './sync_state.js';\nimport { useFeedback } from './feedback_state.js';\nimport { stylestring_to_obj } from \"../helpers/styles.js\";\nimport MathHelper from '../helpers/math.js'; */\nimport { useState } from 'react';\nimport anime from 'animejs';\nexport default class Animation {\n  constructor() {\n    console.log('blegh!');\n  }\n  Start(intialState) {\n    //SetAnimationDone(false);\n    /* animatedRegions = {};\n    specialAnimations = {}; */\n\n    console.log('blegh start!');\n    console.log(intialState);\n    for (let n in intialState) {\n      let element = intialState[n];\n      let selector = element.selector;\n      let selected = Array.from(document.querySelectorAll(selector));\n      console.log(selected);\n      /*\n      \tlet start_styles = stylestring_to_obj(element.style) || {};\n      \tanimationStart.value[selector] = {};\n      animatedElements.value[selector] = [];\n      console.log(selector, selected.length);\n      \tfor (let s in start_styles) {\n      \tfor (let e in selected) {\n      \t\tif (!selected[e].id) {\n      \t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n      \t\t\tlet new_id = app.generateId('animate_');\n      \t\t\tselected[e].id = new_id;\n      \t\t}\n      \t\tconsole.log(selected[e].id);\n      \t\tlet is_svg = selected[e] instanceof SVGElement;\n      \t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n      \t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n      \t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n      \t\t\tconsole.log(length);\n      \t\t\tstart_styles[s] = length;\n      \t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n      \t\t} else if (s == 'pie') {\n      \t\t\tstartPie(selected[e].id);\n      \t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n      \t\t\tlet angles = start_styles[s].split(' ');\n      \t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n      \t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n      \t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n      \t\t\tsetPie(selected[e].id);\n      \t\t}\n      \t\tif (is_svg && svgprops.indexOf(s) != -1) {\n      \t\t\tlet original = selected[e].getAttribute(s);\n      \t\t\tselected[e].setAttribute(s, start_styles[s]);\n      \t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n      \t\t\tspecialAnimations[selected[e].id].original = original;\n      \t\t} else {\n      \t\t\tselected[e].style[s] = start_styles[s];\n      \t\t}\n      \t\tanimationStart.value[selector][s] = start_styles[s];\n      \t}\n      } */\n    }\n  }\n  //props:\n  /* let animatedRegions = {}; //regions to scroll to\n  let specialAnimations = {};\n  \tlet observer;\n  \tconst animatedElements = ref({});\n  const stepDurations = ref([]);\n  const animationStep =  ref(0);\n  const animationDelay = ref(0);\n  \tconst animationDone = ref(false);\n  const animationStart = ref({});\n  \n  //import\n  const { loadingState } = useLoadingState();\n  const { syncing } = useSync();\n  const { feedbackOpen } = useFeedback();\n  const { node, currentIndex } = usePages();\n  \n  \tconst prepareAnimation = async(app)=>{\n  \t//animationStep = 0;\n  \t//animationDelay = 0;\n  \tanimationStart.value = {};\n  \t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n  \t\t//get regions\n  \t\tnode.value.animation.animations.forEach(r=>{\n  \t\t\tlet start_obj = {\n  \t\t\t\tanimationStep:0,\n  \t\t\t\tanimationDelay:0,\n  \t\t\t\tstepDurations:[],\n  \t\t\t\t};\n  \t\t\t\tif (r.trigger){\n  \t\t\t\tconsole.log(r);\n  \t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n  \t\t\t}else{\n  \t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n  \t\t\t}\n  \t\t});\n  \t\t\tconsole.log('prepareAnimation!!');\n  \t\tanimatedElements.value = {};\n  \t\t//stepDurations = [];\n  \n  \t\tconsole.log(animatedRegions);\n  \t\t\tawait nextTick(() => {\n  \t\t\tconsole.log('nextTick');\n  \t\t\tlet target = document.querySelector('#scrollcontent');\n  \t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n  \t\t\t\tconsole.log('default animation!');\n  \t\t\t\tanimate(app, 'default');\n  \t\t\t}else{\n  \t\t\t\tconsole.log(Object.keys(animatedRegions));\n  \t\t\t\tlet opt = {\n  \t\t\t\t\troot: document.querySelector('#nodecontainer'),\n  \t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n  \t\t\t\t};\n  \t\t\t\tlet regions = [];\n  \t\t\t\tobserver = new IntersectionObserver(\n  \t\t\t\t\t(entries)=>{\n  \t\t\t\t\t\tentries.forEach(e=>{\n  \t\t\t\t\t\t\tif (e.isIntersecting){\n  \t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n  \t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n  \t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n  \t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n  \t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n  \t\t\t\t\t\t\t\t\ttarget.triggered = true;\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t});\n  \t\t\t\t\t\t},\n  \t\t\t\t\topt\n  \t\t\t\t);\n  \n  \t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n  \t\t\t\t\tconsole.log(k, val);\n  \t\t\t\t\tlet entry = document.querySelector(k);\n  \t\t\t\t\tregions.push({\n  \t\t\t\t\t\tel:entry,\n  \t\t\t\t\t\tselector:k,\n  \t\t\t\t\t\tthreshold:val.threshold,\n  \t\t\t\t\t\ttriggered:false\n  \t\t\t\t\t});\n  \t\t\t\t\t\tobserver.observe(entry);\n  \t\t\t\t});\n  \t\t\t\tconsole.log(animatedRegions);\n  \t\t\t\tconsole.log(regions);\n  \t\t\t\t}\n  \t\t});\n  \t}\n  };\n  \tconst startAnimation = (app)=>{\n  \tanimationDone.value = false;\n  \tanimatedRegions = {};\n  \tspecialAnimations = {};\n  \t\tif (!app.screenshotsMode && node.value.animation?.start){\n  \t\tlet start_elements = node.value.animation.start;\n  \t\tconsole.log(start_elements);\n  \t\tfor (let n in start_elements) {\n  \t\t\tlet element = start_elements[n];\n  \t\t\tlet selector = element.selector;\n  \t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n  \t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n  \t\t\tanimationStart.value[selector] = {};\n  \t\t\tanimatedElements.value[selector] = [];\n  \t\t\tconsole.log(selector, selected.length);\n  \t\t\t\tfor (let s in start_styles) {\n  \t\t\t\tfor (let e in selected) {\n  \t\t\t\t\tif (!selected[e].id) {\n  \t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n  \t\t\t\t\t\tlet new_id = app.generateId('animate_');\n  \t\t\t\t\t\tselected[e].id = new_id;\n  \t\t\t\t\t}\n  \t\t\t\t\tconsole.log(selected[e].id);\n  \t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n  \t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n  \t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n  \t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n  \t\t\t\t\t\tconsole.log(length);\n  \t\t\t\t\t\tstart_styles[s] = length;\n  \t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n  \t\t\t\t\t} else if (s == 'pie') {\n  \t\t\t\t\t\tstartPie(selected[e].id);\n  \t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n  \t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n  \t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n  \t\t\t\t\t\tsetPie(selected[e].id);\n  \t\t\t\t\t}\n  \t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n  \t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n  \t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n  \t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n  \t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n  \t\t\t\t\t}\n  \t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n  const animate = (app, regionname)=>{\n  \tlet region = animatedRegions[regionname];\n  \tconsole.log(regionname, region);\n  \tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n  \tconsole.log(region.animationStep);\n  \t\tif (region.animationStep > 0) {\n  \t\tlet prevstep = region.steps[region.animationStep - 1];\n  \t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n  \t} else {\n  \t\t//startAnimation(app);\n  \t}\n  \tconsole.log(animationStart.value);\n  \t\tif (region.steps.length) {\n  \t\tlet commands = region.steps[region.animationStep];\n  \t\tconsole.log(commands);\n  \t\tlet elements = commands ? (commands.elements || []) : [];\n  \t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n  \t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n  \t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n  \n  \t\tfor (var n in elements) {\n  \t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n  \t\t\tlet selector = elements[n].selector;\n  \t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\tlet substeps = elements[n].substeps;\n  \t\t\tconsole.log(selector);\n  \t\t\t\t//animeJS\n  \t\t\tif (!animatedElements.value[selector]) {\n  \t\t\t\tanimatedElements.value[selector] = [];\n  \t\t\t}\n  \t\t\tlet step = {\n  \t\t\t\tduration,\n  \t\t\t\toffset: region.animationDelay + stepoffset,\n  \t\t\t\teasing: timing,\n  \t\t\t};\n  \t\t\tif (substeps) {\n  \t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n  \t\t\t\tstep.duration = duration / substeps;\n  \t\t\t}\n  \t\t\t\tconsole.log(specialAnimations);\n  \t\t\tif (styles['pie']) { //pie\n  \t\t\t\tconsole.log('pie!', elements[n].selector);\n  \t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\tstep.targets = [];\n  \t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\tlet id = p.id;\n  \t\t\t\t\tconsole.log(id, specialAnimations[id]);\n  \t\t\t\t\tstep.targets.push(specialAnimations[id]);\n  \t\t\t\t});\n  \t\t\t\tlet angles = styles['pie'].split(' ');\n  \t\t\t\tstep.startAngle = Number(angles[0]);\n  \t\t\t\tstep.endAngle = Number(angles[1]);\n  \t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n  \t\t\t\tstep.update = () => {\n  \t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n  \t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tpies.forEach((p, n) => {\n  \t\t\t\t\t\tlet id = p.id;\n  \t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n  \t\t\t\t\t});\n  \t\t\t\t};\n  \t\t\t\tdelete styles['pie'];\n  \t\t\t\tstep = Object.assign(step, styles);\n  \t\t\t\tconsole.log(step);\n  \t\t\t\tanimatedElements.value[selector].push(step);\n  \t\t\t}\n  \t\t\tfor (let s in styles) {\n  \t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n  \t\t\t\t\tconsole.log('ORIGINAL SVG!');\n  \t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n  \t\t\t\t\tselected.forEach((sel, n) => {\n  \t\t\t\t\t\tlet id = sel.id;\n  \t\t\t\t\t\tconsole.log(id);\n  \t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n  \t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n  \t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n  \t\t\t\t\t}\n  \t\t\t\t\t} else {\n  \t\t\t\t\tanimationStart.value[selector] = {}\n  \t\t\t\t}\n  \t\t\t\tanimationStart.value[selector][s] = styles[s];\n  \t\t\t}\n  \t\t\tconsole.log(styles);\n  \t\t\tstep = Object.assign(step, styles);\n  \t\t\tanimatedElements.value[selector].push(step);\n  \t\t}\n  \t\tregion.animationStep++;\n  \t\tregion.stepDurations.push(duration);\n  \t\tif (region.animationStep < region.steps.length) {\n  \t\t\tanimate(app, regionname);\n  \t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n  \t\t\t//animeJS\n  \t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n  \t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t\tconsole.log(animatedElements.value);\n  \t\t\tfor (let e in animatedElements.value) {\n  \t\t\t\tlet selector_steps = animatedElements.value[e];\n  \t\t\t\tfor (let s in selector_steps) {\n  \t\t\t\t\tlet step = selector_steps[s];\n  \t\t\t\t\tif (!step.targets) step.targets = e;\n  \t\t\t\t\tconsole.log(step);\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\ttimeline = timeline.add(step);\n  \t\t\t\t\t} catch (ex) {\n  \t\t\t\t\t\tconsole.log(ex.message);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tconsole.log(timeline);\n  \t\t} else {\n  \t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n  \t\t}\n  \t}\n  }\n  const cssTimeToMS = (time)=>{\n  \tif (time && time.match(/s$/)) { //seconds\n  \t\treturn parseFloat(time) * 1000;\n  \t} else {\n  \t\treturn parseInt(time);\n  \t}\n  };\n  const startPie = (id)=>{\n  \tconsole.log('starting pie');\n  \tlet element = $id(id);\n  \tif (element) {\n  \t\tlet pie_id = id + '_pie';\n  \t\tlet draw, dims;\n  \t\tif (element instanceof SVGElement) {\n  \t\t\tlet parentsvg = element.closest(\"svg\");\n  \t\t\tdraw = SVG(parentsvg);\n  \t\t\tconsole.log('svg element');\n  \t\t\tif (element.querySelector('clipPath')) {\n  \t\t\t\tdims = element.querySelector('clipPath').getBBox();\n  \t\t\t} else {\n  \t\t\t\tdims = element.getBBox();\n  \t\t\t}\n  \t\t\t} else {\n  \t\t\tconsole.log('not svg element');\n  \t\t\tdims = element.getBoundingClientRect();\n  \t\t\tconsole.log(dims);\n  \t\t}\n  \t\tconsole.log(dims);\n  \t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n  \t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n  \n  \t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n  \t\tconsole.log(center, radius);\n  \t\tspecialAnimations[id].center = center;\n  \t\tspecialAnimations[id].radius = radius;\n  \t\tspecialAnimations[id].startAngle = 0;\n  \t\tspecialAnimations[id].endAngle = 0;\n  \t\tconsole.log('specialAnimations', id, specialAnimations);\n  \t\t//arc\n  \t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n  \t\telement.style.clipPath = `path('${path}')`;\n  \t\tconsole.log(element);\n  \t}\n  };\n  const setPie = (id)=>{\n  \t//console.log('setPie');\n  \tlet center = specialAnimations[id].center;\n  \tlet radius = specialAnimations[id].radius;\n  \tlet start = specialAnimations[id].startAngle;\n  \tlet end = specialAnimations[id].endAngle;\n  \t//console.log(id, start, end);\n  \ttry {\n  \t\tlet path = drawPie(center.x, center.y, radius, start, end);\n  \t\t$id(id).style.clipPath = `path('${path}')`;\n  \t} catch (ex) {\n  \t\tconsole.log(ex.message);\n  \t}\n  }\n  const drawPie = (x, y, radius, startAngle, endAngle)=>{\n  \tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n  \t\tvar d = [\n  \t\t\"M\", x, y,\n  \t\t\"L\", arc.start.x, arc.start.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n  \t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n  \t\t\"Z\"\n  \t].join(\" \");\n  \t//console.log(startAngle, endAngle, d);\n  \treturn d;\n  };\n  \treturn {\n  \tanimatedElements,\n  \tstepDurations,\n  \tanimationStep,\n  \tanimationDelay,\n  \tspecialAnimations,\n  \tanimationDone,\n  \tprepareAnimation,\n  \tstartAnimation\n  } */\n}","map":{"version":3,"names":["useState","anime","Animation","constructor","console","log","Start","intialState","n","element","selector","selected","Array","from","document","querySelectorAll"],"sources":["C:/Users/Jason/projects/animation_queue/src/animation.js"],"sourcesContent":["/* import { ref, nextTick } from '../../js/vue.min.js';\nimport { useLoadingState } from './loading_state.js';\nimport { usePages } from './pages_state.js';\nimport { useSync } from './sync_state.js';\nimport { useFeedback } from './feedback_state.js';\nimport { stylestring_to_obj } from \"../helpers/styles.js\";\nimport MathHelper from '../helpers/math.js'; */\nimport { useState } from 'react';\nimport anime from 'animejs';\n\nexport default class Animation{\n\tconstructor(){\n\t\tconsole.log('blegh!');\n\t}\n\tStart(intialState){\n\t\t//SetAnimationDone(false);\n\t\t/* animatedRegions = {};\n\t\tspecialAnimations = {}; */\n\n\t\tconsole.log('blegh start!');\n\n\t\tconsole.log(intialState);\n\t\tfor (let n in intialState) {\n\t\t\tlet element = intialState[n];\n\t\t\tlet selector = element.selector;\n\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\tconsole.log(selected);\n\t\t\t/*\n\n\t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n\n\t\t\tanimationStart.value[selector] = {};\n\t\t\tanimatedElements.value[selector] = [];\n\t\t\tconsole.log(selector, selected.length);\n\n\t\t\tfor (let s in start_styles) {\n\t\t\t\tfor (let e in selected) {\n\t\t\t\t\tif (!selected[e].id) {\n\t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n\t\t\t\t\t\tlet new_id = app.generateId('animate_');\n\t\t\t\t\t\tselected[e].id = new_id;\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(selected[e].id);\n\t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\tstart_styles[s] = length;\n\t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n\t\t\t\t\t} else if (s == 'pie') {\n\t\t\t\t\t\tstartPie(selected[e].id);\n\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\tsetPie(selected[e].id);\n\t\t\t\t\t}\n\t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n\t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n\t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n\t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n\t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n\t\t\t\t\t}\n\t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n\t\t\t\t}\n\t\t\t} */\n\t\t}\n\n\t}\n\t//props:\n\t/* let animatedRegions = {}; //regions to scroll to\n\tlet specialAnimations = {};\n\n\tlet observer;\n\n\tconst animatedElements = ref({});\n\tconst stepDurations = ref([]);\n\tconst animationStep =  ref(0);\n\tconst animationDelay = ref(0);\n\n\tconst animationDone = ref(false);\n\tconst animationStart = ref({});\n\n\n\t//import\n\tconst { loadingState } = useLoadingState();\n\tconst { syncing } = useSync();\n\tconst { feedbackOpen } = useFeedback();\n\tconst { node, currentIndex } = usePages();\n\n\n\n\tconst prepareAnimation = async(app)=>{\n\t\t//animationStep = 0;\n\t\t//animationDelay = 0;\n\t\tanimationStart.value = {};\n\n\t\tif (node.value && node.value.animation && loadingState.value == 0 && !syncing.value && !feedbackOpen.value && !animationDone.value) {\n\t\t\t//get regions\n\t\t\tnode.value.animation.animations.forEach(r=>{\n\t\t\t\tlet start_obj = {\n\t\t\t\t\tanimationStep:0,\n\t\t\t\t\tanimationDelay:0,\n\t\t\t\t\tstepDurations:[],\n\n\t\t\t\t};\n\n\t\t\t\tif (r.trigger){\n\t\t\t\t\tconsole.log(r);\n\t\t\t\t\tanimatedRegions[r.trigger] = Object.assign(start_obj, r);\n\t\t\t\t}else{\n\t\t\t\t\tanimatedRegions.default = Object.assign(start_obj, r);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('prepareAnimation!!');\n\t\t\tanimatedElements.value = {};\n\t\t\t//stepDurations = [];\n\n\n\t\t\tconsole.log(animatedRegions);\n\n\t\t\tawait nextTick(() => {\n\t\t\t\tconsole.log('nextTick');\n\t\t\t\tlet target = document.querySelector('#scrollcontent');\n\t\t\t\tif (!app.screenshotsMode && node.value && animatedRegions.default && !target){\n\t\t\t\t\tconsole.log('default animation!');\n\t\t\t\t\tanimate(app, 'default');\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log(Object.keys(animatedRegions));\n\t\t\t\t\tlet opt = {\n\t\t\t\t\t\troot: document.querySelector('#nodecontainer'),\n\t\t\t\t\t\tthreshold: Array.from({length:21},(x,i)=>i/20),\n\t\t\t\t\t};\n\t\t\t\t\tlet regions = [];\n\t\t\t\t\tobserver = new IntersectionObserver(\n\t\t\t\t\t\t(entries)=>{\n\t\t\t\t\t\t\tentries.forEach(e=>{\n\t\t\t\t\t\t\t\tif (e.isIntersecting){\n\t\t\t\t\t\t\t\t\tlet target = regions.find(n=>n.el == e.target);\n\n\t\t\t\t\t\t\t\t\tif (!target.triggered && e.intersectionRatio >= target.threshold){\n\t\t\t\t\t\t\t\t\t\tconsole.log('observer entry', e.intersectionRatio, target.selector, target.threshold);\n\n\t\t\t\t\t\t\t\t\t\tconsole.log(`${target.selector} threshold start animation!`);\n\t\t\t\t\t\t\t\t\t\tanimate(app, target.selector);\n\t\t\t\t\t\t\t\t\t\ttarget.triggered = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t},\n\t\t\t\t\t\topt\n\t\t\t\t\t);\n\n\n\t\t\t\t\tObject.entries(animatedRegions).forEach(([k,val])=>{\n\t\t\t\t\t\tconsole.log(k, val);\n\t\t\t\t\t\tlet entry = document.querySelector(k);\n\t\t\t\t\t\tregions.push({\n\t\t\t\t\t\t\tel:entry,\n\t\t\t\t\t\t\tselector:k,\n\t\t\t\t\t\t\tthreshold:val.threshold,\n\t\t\t\t\t\t\ttriggered:false\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tobserver.observe(entry);\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(animatedRegions);\n\t\t\t\t\tconsole.log(regions);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tconst startAnimation = (app)=>{\n\t\tanimationDone.value = false;\n\t\tanimatedRegions = {};\n\t\tspecialAnimations = {};\n\n\t\tif (!app.screenshotsMode && node.value.animation?.start){\n\t\t\tlet start_elements = node.value.animation.start;\n\t\t\tconsole.log(start_elements);\n\t\t\tfor (let n in start_elements) {\n\t\t\t\tlet element = start_elements[n];\n\t\t\t\tlet selector = element.selector;\n\t\t\t\tlet start_styles = stylestring_to_obj(element.style) || {};\n\t\t\t\tlet selected = Array.from(document.querySelectorAll(selector));\n\t\t\t\tanimationStart.value[selector] = {};\n\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\tconsole.log(selector, selected.length);\n\n\t\t\t\tfor (let s in start_styles) {\n\t\t\t\t\tfor (let e in selected) {\n\t\t\t\t\t\tif (!selected[e].id) {\n\t\t\t\t\t\t\t//let new_id = selector.replace(/\\s+/g, '_').replace(/\\W+/g, '')+'_'+e;\n\t\t\t\t\t\t\tlet new_id = app.generateId('animate_');\n\t\t\t\t\t\t\tselected[e].id = new_id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.log(selected[e].id);\n\t\t\t\t\t\tlet is_svg = selected[e] instanceof SVGElement;\n\t\t\t\t\t\tlet svgprops = ['d', 'points', 'x', 'y', 'x1', 'y1', 'x2', 'y2', 'cx', 'cy', 'r', 'rx', 'ry', 'transform'];\n\n\t\t\t\t\t\tif (s == 'stroke-dashoffset' && is_svg) {\n\t\t\t\t\t\t\tlet length = selected[e].getTotalLength() + Number(selected[e].getAttribute('stroke-width'));\n\t\t\t\t\t\t\tconsole.log(length);\n\t\t\t\t\t\t\tstart_styles[s] = length;\n\t\t\t\t\t\t\tselected[e].style.strokeDasharray = length + ' ' + length;\n\t\t\t\t\t\t} else if (s == 'pie') {\n\t\t\t\t\t\t\tstartPie(selected[e].id);\n\t\t\t\t\t\t\t//selected[e].style.clipPath = 'url(#' + selected[e].id + '_clip)';\n\t\t\t\t\t\t\tlet angles = start_styles[s].split(' ');\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].startAngle = Number(angles[0]);\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].endAngle = Number(angles[1]);\n\t\t\t\t\t\t\tconsole.log(selected[e].id, angles[0], angles[1]);\n\t\t\t\t\t\t\tsetPie(selected[e].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_svg && svgprops.indexOf(s) != -1) {\n\t\t\t\t\t\t\tlet original = selected[e].getAttribute(s);\n\t\t\t\t\t\t\tselected[e].setAttribute(s, start_styles[s]);\n\t\t\t\t\t\t\tif (!specialAnimations[selected[e].id]) specialAnimations[selected[e].id] = {};\n\t\t\t\t\t\t\tspecialAnimations[selected[e].id].original = original;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselected[e].style[s] = start_styles[s];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tanimationStart.value[selector][s] = start_styles[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst animate = (app, regionname)=>{\n\t\tlet region = animatedRegions[regionname];\n\t\tconsole.log(regionname, region);\n\t\tif (!region.animationStep) console.log('Start Animate', currentIndex.value);\n\t\tconsole.log(region.animationStep);\n\n\t\tif (region.animationStep > 0) {\n\t\t\tlet prevstep = region.steps[region.animationStep - 1];\n\t\t\tregion.animationDelay += cssTimeToMS(prevstep && prevstep.duration || 0) + (prevstep && prevstep.offset ? cssTimeToMS(prevstep.offset) : 0);\n\t\t} else {\n\t\t\t//startAnimation(app);\n\t\t}\n\t\tconsole.log(animationStart.value);\n\n\t\tif (region.steps.length) {\n\t\t\tlet commands = region.steps[region.animationStep];\n\t\t\tconsole.log(commands);\n\t\t\tlet elements = commands ? (commands.elements || []) : [];\n\t\t\tlet duration = commands ? cssTimeToMS(commands.duration) : 0;\n\t\t\tlet timing = commands ? (commands.timing || 'linear') : 'linear';\n\t\t\tlet stepoffset = commands && commands.offset ? cssTimeToMS(commands.offset) : 0;\n\n\n\t\t\tfor (var n in elements) {\n\t\t\t\tlet styles = stylestring_to_obj(elements[n].style, true) || {};\n\t\t\t\tlet selector = elements[n].selector;\n\n\t\t\t\t//let selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\tlet substeps = elements[n].substeps;\n\t\t\t\tconsole.log(selector);\n\n\t\t\t\t//animeJS\n\t\t\t\tif (!animatedElements.value[selector]) {\n\t\t\t\t\tanimatedElements.value[selector] = [];\n\t\t\t\t}\n\t\t\t\tlet step = {\n\t\t\t\t\tduration,\n\t\t\t\t\toffset: region.animationDelay + stepoffset,\n\t\t\t\t\teasing: timing,\n\t\t\t\t};\n\t\t\t\tif (substeps) {\n\t\t\t\t\tstep.delay = (el, i, l) => i * duration / substeps;\n\t\t\t\t\tstep.duration = duration / substeps;\n\t\t\t\t}\n\n\t\t\t\tconsole.log(specialAnimations);\n\t\t\t\tif (styles['pie']) { //pie\n\t\t\t\t\tconsole.log('pie!', elements[n].selector);\n\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\tstep.targets = [];\n\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\tconsole.log(id, specialAnimations[id]);\n\t\t\t\t\t\tstep.targets.push(specialAnimations[id]);\n\t\t\t\t\t});\n\t\t\t\t\tlet angles = styles['pie'].split(' ');\n\t\t\t\t\tstep.startAngle = Number(angles[0]);\n\t\t\t\t\tstep.endAngle = Number(angles[1]);\n\t\t\t\t\tconsole.log('startAngle', step.startAngle, 'endAngle', step.endAngle);\n\t\t\t\t\tstep.update = () => {\n\t\t\t\t\t\tconsole.log('step.update', step.startAngle, step.endAngle);\n\t\t\t\t\t\tlet pies = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tpies.forEach((p, n) => {\n\t\t\t\t\t\t\tlet id = p.id;\n\t\t\t\t\t\t\tif (specialAnimations[id]) setPie(id);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tdelete styles['pie'];\n\t\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\t\tconsole.log(step);\n\t\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t\t}\n\t\t\t\tfor (let s in styles) {\n\t\t\t\t\tif (styles[s] == 'original' && specialAnimations) {\n\t\t\t\t\t\tconsole.log('ORIGINAL SVG!');\n\t\t\t\t\t\tlet selected = Array.from(document.querySelectorAll(elements[n].selector));\n\t\t\t\t\t\tselected.forEach((sel, n) => {\n\t\t\t\t\t\t\tlet id = sel.id;\n\t\t\t\t\t\t\tconsole.log(id);\n\t\t\t\t\t\t\tif (specialAnimations[id] && specialAnimations[id].original) {\n\t\t\t\t\t\t\t\tstyles[s] = specialAnimations[id].original;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (animationStart.value[selector] && animationStart.value[selector][s]) {\n\t\t\t\t\t\tif (Array.isArray(animationStart.value[selector][s])) {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s][1], styles[s]];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstyles[s] = [animationStart.value[selector][s], styles[s]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tanimationStart.value[selector] = {}\n\t\t\t\t\t}\n\t\t\t\t\tanimationStart.value[selector][s] = styles[s];\n\t\t\t\t}\n\t\t\t\tconsole.log(styles);\n\t\t\t\tstep = Object.assign(step, styles);\n\t\t\t\tanimatedElements.value[selector].push(step);\n\t\t\t}\n\t\t\tregion.animationStep++;\n\t\t\tregion.stepDurations.push(duration);\n\t\t\tif (region.animationStep < region.steps.length) {\n\t\t\t\tanimate(app, regionname);\n\t\t\t} else if (region.animationStep == region.steps.length) { //prevent double animation\n\t\t\t\t//animeJS\n\t\t\t\tlet timeline = anime.timeline({ complete: (anim) => animationDone.value = true });\n\t\t\t\tconsole.log('Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t\tconsole.log(animatedElements.value);\n\t\t\t\tfor (let e in animatedElements.value) {\n\t\t\t\t\tlet selector_steps = animatedElements.value[e];\n\t\t\t\t\tfor (let s in selector_steps) {\n\t\t\t\t\t\tlet step = selector_steps[s];\n\t\t\t\t\t\tif (!step.targets) step.targets = e;\n\t\t\t\t\t\tconsole.log(step);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimeline = timeline.add(step);\n\t\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t\tconsole.log(ex.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(timeline);\n\t\t\t} else {\n\t\t\t\tconsole.log('Not Animating', currentIndex.value, 'step:', region.animationStep, 'total steps:', region.steps.length);\n\t\t\t}\n\t\t}\n\t}\n\tconst cssTimeToMS = (time)=>{\n\t\tif (time && time.match(/s$/)) { //seconds\n\t\t\treturn parseFloat(time) * 1000;\n\t\t} else {\n\t\t\treturn parseInt(time);\n\t\t}\n\t};\n\tconst startPie = (id)=>{\n\t\tconsole.log('starting pie');\n\t\tlet element = $id(id);\n\t\tif (element) {\n\t\t\tlet pie_id = id + '_pie';\n\t\t\tlet draw, dims;\n\t\t\tif (element instanceof SVGElement) {\n\t\t\t\tlet parentsvg = element.closest(\"svg\");\n\t\t\t\tdraw = SVG(parentsvg);\n\t\t\t\tconsole.log('svg element');\n\t\t\t\tif (element.querySelector('clipPath')) {\n\t\t\t\t\tdims = element.querySelector('clipPath').getBBox();\n\t\t\t\t} else {\n\t\t\t\t\tdims = element.getBBox();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tconsole.log('not svg element');\n\t\t\t\tdims = element.getBoundingClientRect();\n\t\t\t\tconsole.log(dims);\n\t\t\t}\n\t\t\tconsole.log(dims);\n\n\t\t\tlet center = { x: dims.width / 2, y: dims.height / 2 };\n\t\t\tlet radius = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));\n\n\n\t\t\tif (!specialAnimations[id]) specialAnimations[id] = {};\n\t\t\tconsole.log(center, radius);\n\t\t\tspecialAnimations[id].center = center;\n\t\t\tspecialAnimations[id].radius = radius;\n\t\t\tspecialAnimations[id].startAngle = 0;\n\t\t\tspecialAnimations[id].endAngle = 0;\n\t\t\tconsole.log('specialAnimations', id, specialAnimations);\n\t\t\t//arc\n\t\t\tlet path = drawPie(center.x, center.y, radius, 0, 0);\n\t\t\telement.style.clipPath = `path('${path}')`;\n\t\t\tconsole.log(element);\n\t\t}\n\t};\n\tconst setPie = (id)=>{\n\t\t//console.log('setPie');\n\t\tlet center = specialAnimations[id].center;\n\t\tlet radius = specialAnimations[id].radius;\n\t\tlet start = specialAnimations[id].startAngle;\n\t\tlet end = specialAnimations[id].endAngle;\n\t\t//console.log(id, start, end);\n\t\ttry {\n\t\t\tlet path = drawPie(center.x, center.y, radius, start, end);\n\t\t\t$id(id).style.clipPath = `path('${path}')`;\n\t\t} catch (ex) {\n\t\t\tconsole.log(ex.message);\n\t\t}\n\t}\n\tconst drawPie = (x, y, radius, startAngle, endAngle)=>{\n\t\tvar arc = MathHelper.arcValues(x, y, radius, startAngle, endAngle);\n\n\t\tvar d = [\n\t\t\t\"M\", x, y,\n\t\t\t\"L\", arc.start.x, arc.start.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.start2.x, arc.start2.y,\n\t\t\t\"A\", radius, radius, 0, arc.largeArcFlag, 1, arc.end.x, arc.end.y,\n\t\t\t\"Z\"\n\t\t].join(\" \");\n\t\t//console.log(startAngle, endAngle, d);\n\t\treturn d;\n\t};\n\n\treturn {\n\t\tanimatedElements,\n\t\tstepDurations,\n\t\tanimationStep,\n\t\tanimationDelay,\n\t\tspecialAnimations,\n\t\tanimationDone,\n\t\tprepareAnimation,\n\t\tstartAnimation\n\t} */\n}\n\n\n\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,OAAO;AAChC,OAAOC,KAAK,MAAM,SAAS;AAE3B,eAAe,MAAMC,SAAS;EAC7BC,WAAWA,CAAA,EAAE;IACZC,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;EACtB;EACAC,KAAKA,CAACC,WAAW,EAAC;IACjB;IACA;AACF;;IAEEH,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;IAE3BD,OAAO,CAACC,GAAG,CAACE,WAAW,CAAC;IACxB,KAAK,IAAIC,CAAC,IAAID,WAAW,EAAE;MAC1B,IAAIE,OAAO,GAAGF,WAAW,CAACC,CAAC,CAAC;MAC5B,IAAIE,QAAQ,GAAGD,OAAO,CAACC,QAAQ;MAC/B,IAAIC,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAACC,QAAQ,CAACC,gBAAgB,CAACL,QAAQ,CAAC,CAAC;MAC9DN,OAAO,CAACC,GAAG,CAACM,QAAQ,CAAC;MACrB;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAKE;EAED;EACA;EACA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}